<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>认识复杂度、对数器、二分法与异或运算 | fox_blog</title><meta name="author" content="HITlittlefox"><meta name="copyright" content="HITlittlefox"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="认识复杂度 评估算法优劣的核心指标是什么？ 时间复杂度（流程决定） 额外空间复杂度（流程决定） 常数项时间（实现细节决定）   什么是常数项时间？ 数组的寻址操作，是一个常数项时间操作，每次执行时间都是固定时间，与数据量的大小无关. 常见的常数时间的操作 常见的算数运算（+、-、*、&#x2F;、%等） 常见的位运算   [带符号位，统一右移，然后看符号位是什么就用什么补]、&gt;&gt;&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="认识复杂度、对数器、二分法与异或运算">
<meta property="og:url" content="http://example.com/2022/07/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/index.html">
<meta property="og:site_name" content="fox_blog">
<meta property="og:description" content="认识复杂度 评估算法优劣的核心指标是什么？ 时间复杂度（流程决定） 额外空间复杂度（流程决定） 常数项时间（实现细节决定）   什么是常数项时间？ 数组的寻址操作，是一个常数项时间操作，每次执行时间都是固定时间，与数据量的大小无关. 常见的常数时间的操作 常见的算数运算（+、-、*、&#x2F;、%等） 常见的位运算   [带符号位，统一右移，然后看符号位是什么就用什么补]、&gt;&gt;&amp;gt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-07-04T07:02:24.000Z">
<meta property="article:modified_time" content="2024-02-10T12:47:34.082Z">
<meta property="article:author" content="HITlittlefox">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "认识复杂度、对数器、二分法与异或运算",
  "url": "http://example.com/2022/07/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2022-07-04T07:02:24.000Z",
  "dateModified": "2024-02-10T12:47:34.082Z",
  "author": [
    {
      "@type": "Person",
      "name": "HITlittlefox",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '认识复杂度、对数器、二分法与异或运算',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">fox_blog</span></a><a class="nav-page-title" href="/"><span class="site-name">认识复杂度、对数器、二分法与异或运算</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">认识复杂度、对数器、二分法与异或运算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-07-04T07:02:24.000Z" title="Created 2022-07-04 15:02:24">2022-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-10T12:47:34.082Z" title="Updated 2024-02-10 20:47:34">2024-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%88%91%E8%A6%81%E5%B0%B1%E4%B8%9A/">我要就业</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="认识复杂度"><a href="#认识复杂度" class="headerlink" title="认识复杂度"></a>认识复杂度</h2><ol>
<li>评估算法优劣的核心指标是什么？<ul>
<li>时间复杂度（流程决定）</li>
<li>额外空间复杂度（流程决定）</li>
<li>常数项时间（实现细节决定）</li>
</ul>
</li>
<li>什么是常数项时间？<ol>
<li>数组的寻址操作，是一个常数项时间操作，每次执行时间都是固定时间，<strong>与数据量的大小无关</strong>.</li>
<li>常见的常数时间的操作<ol>
<li>常见的算数运算（+、-、*、&#x2F;、%等）</li>
<li>常见的位运算<ol>
<li><blockquote>
<blockquote>
<p>[带符号位，统一右移，然后看符号位是什么就用什么补]、&gt;&gt;&gt;[不带符号位]、&lt;&lt;、|、&amp;、^等）</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li>赋值、比较、自增、自减操作等</li>
<li>数组寻址操作</li>
</ol>
</li>
<li>反例:Java:LinkedList:这个在底层属于双向链表，如果你要list.get(5)，那么并不会像数组寻址那样直接计算偏移量，而是一个一个地去遍历，到了合适的位置才取值，这个就不是常数项时间。</li>
</ol>
</li>
<li>执行时间固定的操作,就是常数时间的操作.</li>
<li>执行时间不固定的操作,都不是常数时间的操作.</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li>定性描述该算法的运行时间</li>
<li>如何确定算法流程的总操作数量与样本数量之间的表达式关系？<ol>
<li>想象该算法流程所处理的数据状况，要按照最差的情况来。</li>
<li>把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。</li>
<li>如果数据量为N，看看基本动作的数量和N是什么关系。</li>
</ol>
</li>
<li>时间复杂度怎么表达？<ol>
<li>当完成了表达式的建立后，<strong>只要把最高阶项留下即可</strong>。低阶项都去掉，高阶项的系数也要去掉，记为O(忽略掉系数的高阶项)</li>
</ol>
</li>
<li>时间复杂度的意义？<ol>
<li>时间复杂度是衡量算法流程复杂程度的一种指标，这个指标只与数据量有关，与过程之外的优化无关.</li>
<li>O(1) &lt; O(logN) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; … &lt; O(N^k) &lt; O(2^n) &lt; … &lt; O(k^n) &lt; O(n!)</li>
</ol>
</li>
</ol>
<h3 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h3><ol>
<li>什么是空间复杂度？<ol>
<li>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。作为输入参数的空间，不算额外空间，作为输出结果的空间，也不算额外空间。因为这些都是必要的，和现实目标有关的，所以都不算。但是除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去，这部分空间就是额外空间，如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</li>
</ol>
</li>
<li>最优解,什么是最优解？<ol>
<li>时间复杂度尽可能得低，</li>
<li>先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫做这个问题的最优解。</li>
<li>一般来说最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</li>
</ol>
</li>
</ol>
<h3 id="认识对数器"><a href="#认识对数器" class="headerlink" title="认识对数器"></a>认识对数器</h3><ol>
<li>你想要测的方法a。</li>
<li>实现复杂度不好但是容易实现的方法b。</li>
<li>实现一个随机样本产生器。</li>
<li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。</li>
<li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b。</li>
<li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</li>
</ol>
<h2 id="二分法O-logN"><a href="#二分法O-logN" class="headerlink" title="二分法O(logN)"></a>二分法O(logN)</h2><ol>
<li>在一个有序数组中，找某个数是否存在</li>
</ol>
<pre><code class="java">public static boolean exist(int[] sortedArr, int num) &#123;
    if (sortedArr == null || sortedArr.length == 0) &#123;
        return false;
    &#125;
    int L = 0;
    int R = sortedArr.length - 1;
    int mid = 0;
    // L..R
    while (L &lt; R) &#123;
        // L..R 至少两个数的时候
        // mid = (L+R) / 2;
        // L 10亿  R 18亿
        // mid = L + (R - L) / 2
        // N / 2    N &gt;&gt; 1
        // X*2+1可以表示为( X&lt;&lt;2 | 1 )

        // mid = (L + R) / 2
        mid = L + ((R - L) &gt;&gt; 1);
        if (sortedArr[mid] == num) &#123;
            return true;
        &#125; else if (sortedArr[mid] &gt; num) &#123;
            R = mid - 1;
        &#125; else &#123;
            L = mid + 1;
        &#125;
    &#125;
    return sortedArr[L] == num;
&#125;
</code></pre>
<ol start="2">
<li>在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</li>
</ol>
<pre><code class="java">// 在arr上，找满足&gt;=value的最左位置
public static int nearestIndex(int[] arr, int value) &#123;
    int L = 0;
    int R = arr.length - 1;
    int index = -1; // 记录最左的对号
    while (L &lt;= R) &#123; // 至少一个数的时候
        int mid = L + ((R - L) &gt;&gt; 1);
        if (arr[mid] &gt;= value) &#123;
            index = mid;
            R = mid - 1;
        &#125; else &#123;
            L = mid + 1;
        &#125;
    &#125;
    return index;
&#125;
</code></pre>
<ol start="3">
<li>在一个有序数组中，找&lt;&#x3D;某个数最右侧的位置</li>
</ol>
<pre><code class="java">// 在arr上，找满足&lt;=value的最右位置
public static int nearestIndex(int[] arr, int value) &#123;
    int L = 0;
    int R = arr.length - 1;
    int index = -1; // 记录最右的对号
    while (L &lt;= R) &#123;
        int mid = L + ((R - L) &gt;&gt; 1);
        if (arr[mid] &lt;= value) &#123;
            index = mid;
            L = mid + 1;
        &#125; else &#123;
            R = mid - 1;
        &#125;
    &#125;
    return index;
&#125;
</code></pre>
<ol start="4">
<li>局部最小值问题(返回一个局部最小值就好)<ol>
<li>只要知道左右有一侧可以有结果,就可以舍去另一侧,就可以二分</li>
</ol>
</li>
</ol>
<pre><code class="java">// 课上的代码
public static int getLessIndex(int[] arr) &#123;
    if (arr == null || arr.length == 0) &#123;
        return -1;
    &#125;
    if (arr.length == 1 || arr[0] &lt; arr[1]) &#123;
        return 0;
    &#125;
    if (arr[arr.length - 1] &lt; arr[arr.length - 2]) &#123;
        return arr.length - 1;
    &#125;
    // 到了这里，我们就明白趋势了。先下后上，所以一定会存在最小值。
    int left = 1;
    int right = arr.length - 2;
    int mid = 0;
    while (left &lt; right) &#123;
        mid = (left + right) / 2;
        if (arr[mid] &gt; arr[mid - 1]) &#123;
            right = mid - 1;
        &#125; else if (arr[mid] &gt; arr[mid + 1]) &#123;
            left = mid + 1;
        &#125; else &#123;
            return mid;
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<ol start="5">
<li>补充知识<ol>
<li>N*2 可以写作 N&lt;&lt;1</li>
<li>N*2+1 可以写作 (N&lt;&lt;1)|1</li>
</ol>
</li>
</ol>
<h2 id="认识异或运算"><a href="#认识异或运算" class="headerlink" title="认识异或运算"></a>认识异或运算</h2><ol>
<li>异或运算（^）：相同则0，不同则1；同或运算（⊙）：相同则1，不同则0。<ol>
<li>能长时间记住的概率接近0%，所以，异或运算就记成<strong>无进位相加</strong></li>
<li>（无进位是什么意思？就是二进制去相加，即便两者都是1，相加结果是2，不要进位，也就是得到0且不要进位）。</li>
</ol>
</li>
<li>异或运算的性质<ol>
<li>0^N &#x3D;&#x3D; N、N^N &#x3D;&#x3D; 0。</li>
</ol>
</li>
<li>异或运算满足交换律和结合律。</li>
<li>上面的两个性质用<strong>无进位相加</strong>来理解就非常得容易。 </li>
<li>例子:</li>
<li><strong>如何不需要额外的变量即可实现两个数字的交换</strong>(但是特别注意，只有两个变量用的不是同一个内存的时候才可以这样干！)<img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-11-49.png"><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-12-10.png"></li>
</ol>
<pre><code class="java">public class Test01 &#123;

    public static void main(String[] args) &#123;
        // 如何不需要额外的变量即可实现两个数字的交换，但是特别注意，只有两个变量用的不是同一个内存的时候才可以这样干！
        int a = 10;
        int b = 4;
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        // b = a ^ b ^ b = a ^ 0 = a; 运用交换律和结合律
        // a = a ^ b = a ^ b ^ a ^ b ^ b = a ^ a ^ b ^ b ^ b = b; 运用交换律和结合律
        System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><strong>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这个数字？</strong><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-19-26.png"><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-23-30.png"></li>
</ol>
<pre><code class="java">public class Test &#123;

    // 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这个数字？
    public static void printOddTimesNum1(int[] arr)&#123;
        int eor = arr[0];
        for(int i = 1; i &lt; arr.length;i++)&#123;
            eor ^= arr[i];
        &#125;
        System.out.println(eor);
    &#125;
    public static void main(String[] args) &#123;
        
        int[] arr = new int[]&#123;1,1,2,2,3,3,4&#125;;
        printOddTimesNum1(arr);
    &#125;
&#125;
</code></pre>
<ol start="3">
<li><strong>怎么把一个整数，提取出最右侧的1来</strong><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-26-43.png"></li>
</ol>
<pre><code class="java">public class Test &#123;

    // 怎么把一个整数，提取出最右侧的1来
    public static int func(int number)&#123;
        // 00000011 01010000
        // 11111100 10101111 （取反）
        // 11111100 10110000 （加1）
        // 00000000 00010000 （与）
        return number &amp; ((~number) + 1);
    &#125;
    public static void main(String[] args) &#123;

        int num = 234;
        System.out.println(func(num));
    &#125;
&#125;
</code></pre>
<ol start="4">
<li><strong>arr中，有两种数，出现奇数次</strong><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-22-34-24.png"><img src="https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-04-23-49-13.png"></li>
</ol>
<pre><code class="java">public class Test &#123;

    // arr中，有两种数，出现奇数次
    public static void printOddTimesNum2(int[] arr) &#123;
        int eor = 0;
        for (int i = 0; i &lt; arr.length; i++) &#123;
            eor ^= arr[i];
        &#125;
        // eor = a ^ b
        // eor != 0
        // eor必然有一个位置上是1
        // 0110010000
        // 0000010000
        int rightOne = eor &amp; (~eor + 1); // 提取出最右的1
        int onlyOne = 0; // eor&#39;
        for (int i = 0 ; i &lt; arr.length;i++) &#123;
            //  arr[1] =  111100011110000
            // rightOne=  000000000010000
            if ((arr[i] &amp; rightOne) != 0) &#123;
                onlyOne ^= arr[i];
            &#125;
        &#125;
        System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));
    &#125;

    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li><strong>看一个数字的二进制样式中有几个1</strong></li>
</ol>
<pre><code class="java">public class Test &#123;

    // 看一个数字的二进制样式中有几个1
    public static int func(int num)&#123;
        int count = 0;
        while(num != 0)&#123;
            int rightOne = num &amp; ((~num) + 1);
            count++;
            num ^= rightOne;
        &#125;
        return count;
    &#125;
    public static void main(String[] args) &#123;
        int num = 234;
        System.out.println(func(num));
    &#125;
&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">HITlittlefox</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/">http://example.com/2022/07/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%AF%B9%E6%95%B0%E5%99%A8%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/07/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" title="归并排序和快速排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">归并排序和快速排序</div></div><div class="info-2"><div class="info-item-1">归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略 分治法将问题分(divide)成一些小的问题然后递归求解， 而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之。   图解排序算法(四)之归并排序   快速排序 荷兰国旗1.0 给定一个数组arr，和一个数num。把&lt;&#x3D;num的数放在数组的左边, &gt;num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(1)。 思路：单指针记录&lt;&#x3D;num的范围 (start from -1)。 若arr[i] &lt;&#x3D; num，则arr[i]和&lt;&#x3D;区域的下一个数字作交换，&lt;&#x3D;区右扩，i++。 若arr[i]&gt;num，则直接i++。     荷兰国旗2.0 给定一个数组arr，和一个数num。把&lt;num的数放在数组的左边,...</div></div></div></a><a class="pagination-related" href="/2022/07/04/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%80%92%E5%BD%92%E8%A1%8C%E4%B8%BA%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/" title="链表结构、栈、队列、递归行为、哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">链表结构、栈、队列、递归行为、哈希表</div></div><div class="info-2"><div class="info-item-1">链表结构 单向链表的定义  public class Node&#123;     public int value;     public Node next;      public Node(int data)&#123;         value = data;     &#125; &#125;   双向链表的定义  public class DoubleNode&#123;     public int value;     public Node last;     public Node next;      public DoubleNode(int data)&#123;         value = data;     &#125; &#125;   单向链表和双向链表最简单的练习:链表相关的题基本上都是coding的题 单链表和双链表的逆序问题    public static Node reverseLinkedList(Node head) &#123;     Node pre = null;     Node next = null;    ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HITlittlefox</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">认识复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">额外空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%AF%B9%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">认识对数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95O-logN"><span class="toc-number">2.</span> <span class="toc-text">二分法O(logN)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">认识异或运算</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/%E8%A7%A3%E5%86%B3%E4%B8%80%E6%AC%A1adapter%E5%B5%8C%E5%A5%97%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/" title="解决一次adapter嵌套不更新内容">解决一次adapter嵌套不更新内容</a><time datetime="2025-03-28T14:51:04.000Z" title="Created 2025-03-28 22:51:04">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/%E8%A7%A3%E5%86%B3%E4%B8%80%E6%AC%A1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="解决一次时间复杂度">解决一次时间复杂度</a><time datetime="2025-03-28T14:32:38.000Z" title="Created 2025-03-28 22:32:38">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/onCreateViewHolder/" title="onCreateViewHolder">onCreateViewHolder</a><time datetime="2025-02-17T14:17:07.000Z" title="Created 2025-02-17 22:17:07">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/%E8%A7%A3bug%E8%AF%B7%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0%E5%88%86%E6%94%AF/" title="解bug请拉取最新分支">解bug请拉取最新分支</a><time datetime="2025-01-20T14:19:26.000Z" title="Created 2025-01-20 22:19:26">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/17/Skeleton-Layout/" title="Skeleton Layout">Skeleton Layout</a><time datetime="2025-01-17T15:34:23.000Z" title="Created 2025-01-17 23:34:23">2025-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HITlittlefox</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.2.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>