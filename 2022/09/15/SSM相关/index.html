<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSM相关 | fox_blog</title><meta name="author" content="HITlittlefox"><meta name="copyright" content="HITlittlefox"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring 基础 什么是 Spring 框架?  Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发 IoC AOP 快速访问数据库 集成第三方组件（电子邮件，任务，调度，缓存等等） 对单元测试支持比较好 支持">
<meta property="og:type" content="article">
<meta property="og:title" content="SSM相关">
<meta property="og:url" content="http://example.com/2022/09/15/SSM%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="fox_blog">
<meta property="og:description" content="Spring 基础 什么是 Spring 框架?  Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发 IoC AOP 快速访问数据库 集成第三方组件（电子邮件，任务，调度，缓存等等） 对单元测试支持比较好 支持">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-09-15T14:04:31.000Z">
<meta property="article:modified_time" content="2024-02-10T12:47:33.844Z">
<meta property="article:author" content="HITlittlefox">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSM相关",
  "url": "http://example.com/2022/09/15/SSM%E7%9B%B8%E5%85%B3/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2022-09-15T14:04:31.000Z",
  "dateModified": "2024-02-10T12:47:33.844Z",
  "author": [
    {
      "@type": "Person",
      "name": "HITlittlefox",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/15/SSM%E7%9B%B8%E5%85%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSM相关',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">fox_blog</span></a><a class="nav-page-title" href="/"><span class="site-name">SSM相关</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">SSM相关</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-09-15T14:04:31.000Z" title="Created 2022-09-15 22:04:31">2022-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-10T12:47:33.844Z" title="Updated 2024-02-10 20:47:33">2024-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%88%91%E8%A6%81%E5%B0%B1%E4%B8%9A/">我要就业</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h3><ol>
<li><p>什么是 Spring 框架?</p>
<ol>
<li>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</li>
<li>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发<ol>
<li>IoC</li>
<li>AOP</li>
<li>快速访问数据库</li>
<li>集成第三方组件（电子邮件，任务，调度，缓存等等）</li>
<li>对单元测试支持比较好</li>
<li>支持 RESTful Java 应用程序的开发</li>
</ol>
</li>
<li>Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。</li>
<li>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</li>
<li>Spring 提供的核心功能主要是 IoC 和 AOP。</li>
</ol>
</li>
<li><p>Spring,Spring MVC,Spring Boot 之间什么关系?</p>
<ol>
<li>Spring 包含了多个功能模块（上面刚刚提高过），<ol>
<li>其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， </li>
<li>Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</li>
</ol>
</li>
<li>Spring MVC 是 Spring 中的一个很重要的模块，<ol>
<li>主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。</li>
<li>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，</li>
<li>其核心思想是<strong>通过将业务逻辑、数据、显示分离</strong>来组织代码。</li>
</ol>
</li>
<li>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。<ol>
<li>使用 Spring 开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。</li>
<li>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</li>
</ol>
</li>
</ol>
</li>
<li><p>Spring IoC</p>
<ol>
<li>谈谈自己对于 Spring IoC 的了解</li>
<li>IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</li>
<li>为什么叫控制反转？<ol>
<li>控制 ：指的是对象创建（实例化、管理）的权力</li>
<li>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ol>
</li>
<li>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。简化应用开发。</li>
<li><img src="https://raw.githubusercontent.com/HITlittlefox/pictures/master/images/20220915233823.png" alt="20220915233823"></li>
<li>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体</li>
<li>IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</li>
<li>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</li>
</ol>
</li>
<li><p>什么是 Spring Bean？</p>
<ol>
<li>Bean 代指的就是那些被 IoC 容器所管理的对象。</li>
<li>通过配置元数据来定义 Bean。</li>
<li>配置元数据可以是 XML 文件、注解或者 Java 配置类。<pre><code class="xml">&lt;!-- Constructor-arg with &#39;value&#39; attribute --&gt;
&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
&lt;constructor-arg value=&quot;...&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>IoC 容器如何使用配置元数据来管理对象<ol>
<li><img src="https://raw.githubusercontent.com/HITlittlefox/pictures/master/images/20220916001816.png" alt="20220916001816"></li>
</ol>
</li>
</ol>
</li>
<li><p>将一个类声明为 Bean 的注解有哪些?</p>
<ol>
<li>(不常用)@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
<li>@Configuration : 指示一个类声明一个或多个@Bean方法，并且可以由Spring容器处理，以便在运行时为这些bean生成BeanDefinition和服务请求</li>
</ol>
</li>
<li><p>@Component 和 @Bean 的区别是什么？</p>
<ol>
<li>注解作用对象不同<ol>
<li>@Component 注解作用于类</li>
<li>@Bean 注解作用于方法</li>
</ol>
</li>
<li>自动装配与否<ol>
<li>@Component 通常是通过<strong>类路径扫描</strong>来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</li>
<li>@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean, @Bean 告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
</ol>
</li>
<li>自定义性不同<ol>
<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。</li>
<li>比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li>
</ol>
</li>
</ol>
</li>
<li><p>@Bean注解使用示例：</p>
<pre><code class="java">@Configuration
public class AppConfig &#123;
    @Bean
    public TransferService transferService() &#123;
        return new TransferServiceImpl();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;beans&gt;
    &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>注入 Bean 的注解有哪些？</p>
<ol>
<li>Spring 内置的 @Autowired </li>
<li>JDK 内置的 @Resource 和 @Inject</li>
<li>@Autowired 和@Resource使用的比较多一些</li>
</ol>
</li>
<li><p>@Autowired 和 @Resource 的区别是什么？</p>
<ol>
<li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li>
<li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。</li>
<li>Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称</li>
</ol>
</li>
<li><p>Bean 的作用域有哪些?</p>
<ol>
<li>singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li>prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。</li>
<li>request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li>session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li>application&#x2F;global-session （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。</li>
<li>websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ol>
</li>
<li><p>如何配置 bean 的作用域呢？</p>
<pre><code class="xml">&lt;!-- xml 方式： --&gt;
&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">// 注解方式：
@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() &#123;
    return new Person();
&#125;
</code></pre>
</li>
<li><p>单例 Bean 的线程安全问题了解吗？</p>
<ol>
<li>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</li>
<li>常见的有两种解决办法：<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
<li>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</li>
</ol>
</li>
</ol>
</li>
<li><p>Bean 的生命周期了解么?</p>
<ol>
<li>…</li>
</ol>
</li>
</ol>
<h3 id="Spring-与-设计模式"><a href="#Spring-与-设计模式" class="headerlink" title="Spring 与 设计模式"></a>Spring 与 设计模式</h3><ol>
<li>Spring 框架中用到了哪些设计模式？<ol>
<li>工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li>适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>
</ol>
</li>
<li>单例设计模式<ol>
<li>在我们的系统中，有一些对象其实我们只需要一个，比如说：<ol>
<li>一类对象只能有一个实例：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。</li>
<li>如果制造出多个实例就可能会导致一些问题产生</li>
<li>比如：程序的行为异常、资源使用过量、或者不一致性的结果。</li>
</ol>
</li>
<li>使用单例模式的好处:<ol>
<li>减少创建对象所花费的时间，减少系统开销；</li>
<li>减少系统内存的使用频率，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
<li>Spring 中 bean 的默认作用域就是 singleton(单例)的。</li>
</ol>
</li>
<li>Spring 中 bean 还有下面几种作用域：prototype、request、session、global-session</li>
<li>Spring 实现单例的方式：<ol>
<li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ol>
</li>
<li>Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</li>
</ol>
</li>
</ol>
<pre><code class="java">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(64);

public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;
        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);
        synchronized (this.singletonObjects) &#123;
            // 检查缓存中是否存在实例  
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) &#123;
                //...省略了很多代码
                try &#123;
                    singletonObject = singletonFactory.getObject();
                &#125;
                //...省略了很多代码
                // 如果实例对象在不存在，我们注册到单例注册表中。
                addSingleton(beanName, singletonObject);
            &#125;
            return (singletonObject != NULL_OBJECT ? singletonObject : null);
        &#125;
        //将对象添加到单例注册表
        protected void addSingleton(String beanName, Object singletonObject) &#123;
                synchronized (this.singletonObjects) &#123;
                    this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
                &#125;
            &#125;
&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">HITlittlefox</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/15/SSM%E7%9B%B8%E5%85%B3/">http://example.com/2022/09/15/SSM%E7%9B%B8%E5%85%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/09/12/%E4%BB%8E%E5%BF%AB%E6%8E%92%E6%83%B3%E5%88%B0%E7%9A%84/" title="从快排想到的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">从快排想到的</div></div><div class="info-2"><div class="info-item-1"> 首先我们先知道什么是快排 快速排序是一种基于分而治之的排序算法，其中： 通过从数组中选择一个中心元素将数组划分成两个子数组，在划分数组时， 将比中心元素小的元素放在左子数组， 将比中心元素大的元素放在右子数组。   左子数组和右子数组也使用相同的方法进行划分，这个过程一直持续到每个子数组都包含一个元素为止。 最后，将元素组合在一起以形成排序的数组。   中心元素（pivot element)：有的地方翻译为：枢轴元素、基元，基准元素，我这里就叫做中心元素  </div></div></div></a><a class="pagination-related" href="/2023/02/09/%E5%AF%92%E5%81%87%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" title="寒假做了什么？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">寒假做了什么？</div></div><div class="info-2"><div class="info-item-1"> 寒假和女朋友一起做了很多事 疯狂玩游戏,TTF2,POE,PUBG 注重生活,和爷爷奶奶过年,有只小猫咪    去看了满江红    后来又去爬泰山    回来了吃好吃的小包子    明天吃元宵吃涮锅子,还有城里放好多好多烟花,村里还表演节目,明天一起看. 元宵节晚上看超级多的烟花,满城的人都去看了,堵车堵了好久,烟花放了一个小时,超级好看    准备开始做毕设 小程序学习 前端 demo 已经会跑了   后端也已经有思路了 支持加餐的 temporary order 结账 final order   推荐系统的书要开始看喽 todo 新功能:随账号的个性化体验   毕设规划 2 月 4 日-2 月 10 日 微信小程序入门与实战 完成前端设计稿图   2 月 10 日-2 月 15 日 Spring Boot 双版本(1.5&#x2F;2.1) 打造企业级微信点餐系统 完成后端设计稿图   2 月 15 日-2 月 20 日 微信小程序前端 demo 后端逻辑 demo      </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HITlittlefox</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Spring 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%B8%8E-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Spring 与 设计模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/%E8%A7%A3%E5%86%B3%E4%B8%80%E6%AC%A1adapter%E5%B5%8C%E5%A5%97%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/" title="解决一次adapter嵌套不更新内容">解决一次adapter嵌套不更新内容</a><time datetime="2025-03-28T14:51:04.000Z" title="Created 2025-03-28 22:51:04">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/%E8%A7%A3%E5%86%B3%E4%B8%80%E6%AC%A1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="解决一次时间复杂度">解决一次时间复杂度</a><time datetime="2025-03-28T14:32:38.000Z" title="Created 2025-03-28 22:32:38">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/onCreateViewHolder/" title="onCreateViewHolder">onCreateViewHolder</a><time datetime="2025-02-17T14:17:07.000Z" title="Created 2025-02-17 22:17:07">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/%E8%A7%A3bug%E8%AF%B7%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0%E5%88%86%E6%94%AF/" title="解bug请拉取最新分支">解bug请拉取最新分支</a><time datetime="2025-01-20T14:19:26.000Z" title="Created 2025-01-20 22:19:26">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/17/Skeleton-Layout/" title="Skeleton Layout">Skeleton Layout</a><time datetime="2025-01-17T15:34:23.000Z" title="Created 2025-01-17 23:34:23">2025-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HITlittlefox</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.2.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>