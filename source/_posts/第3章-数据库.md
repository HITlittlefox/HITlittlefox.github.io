---
title: 第3章-数据库
category: 我要就业
date: 2022-08-29 10:49:23
tags:
---
1. 数据库架构 (12:59)
    1. 关系型数据库
        1. 架构
        2. **索引**
        3. **锁**
        4. 语法
        5. 理论范式
    2. 如何设计一个关系型数据库？
        1. 存储部分+程序实例模块：数据库最主要的功能是**存储数据**，因此有一个存储模块存储数据。存储模块类似OS文件系统，将数据持久化存入磁盘中，如存入机械硬盘、SSD固态硬盘、亦或者是它们的磁盘阵列矩阵中。但是只有存储是不行的，还需要**组织并且用到这些数据**，因此需要有程序的实例，用逻辑结构来映射出物理结构，并且在程序中提供获取和管理数据的方式，以及提供必要的问题追踪机制。
        2. 细分程序模块：
            1. 数据逻辑关系转换成物理存储关系的**存储管理模块**：首先对数据的格式和文件的分隔进行统一的管理，即把物理数据通过逻辑的形式组织表示出来，便涉及到程序的存储管理模块。（优化存储效能：处理数据不在磁盘上做，而是加载到程序空间所在内存里，磁盘IO速率是程序执行速率的主要瓶颈，远差于内存的执行效率。为了执行效率，要尽可能减少IO。就存储管理而言，如果按照逐行查找并返回，频繁的IO会使数据库的执行效率慢。因为一次IO读取单条数据和多条数据没有太大的区别，所以可以一次性的读取多行，以提升IO的效能。行就失去了意义，**数据库以块和页作为逻辑存储单位**，每个块和页中存放多行数据，读取的时候将多个块和页加载进内存中。）
            2. 优化执行效率的**缓存模块**：为了更快更好的优化利用内存，可以利用**缓存机制**，把取出来的数据块放进缓存里，下次需要的时候直接从内存返回，而不用发生IO。一次性加载多个模块或者页，块里包含的数据行有数据可能不是我们本次查询需要的行，但是一旦某行数据被访问了，它周围的数据也极有可能被访问的经验，缓存的非本质数据也能起到优化访问效率的作用，提升访问的性能。管理缓存的方法有LRU等。
            3. 将SQL语句解析的**SQL解析模块**：提供外部指令操纵数据，即可读的SQL语言，需要SQL解析模块将SQL编译解析，转换成机器可识别的指令。这时为了进一步提升SQL的执行效率，将SQL缓存到缓存里直接解析。缓存不宜过大，且有算法里淘汰机制，淘汰掉之后不常用的数据。
            4. 记录操作的**日志管理模块**：SQL操作需要记录下来，方便数据库的主从同步或者灾难恢复，因此需要日志管理对操作进行记录，如binlog的记录方式。
            5. 多用户管理的**权限划分模块**：还需要提供给用户管理数据的私密空间，即权限划分。通俗将就是老板可以看到员工的数据，员工只能看到自己该看到的数据。权限划分是DBA做的。
            6. **灾难恢复模块**：除了考虑正常情况，还需考虑异常情况，需要引入异常机制，即容灾机制。当数据库挂了如何恢复，恢复到什么程度。
            7. 优化数据查询效率的**索引模块**
            8. 使得数据库支持并发操作的**锁模块**：为了进一步提升查询数据的速度以及让数据库支持并发，需要引入索引和锁模块。
    3. 索引模块（常见问题）
        1. 为什么要使用索引？
            1. 快速查询数据（最简单的方式实现数据查询，即全表扫描，将整张表的数据全部或者分批次加载到内存中。存储的最小单位是块或者页，他们是由多行数据组成。将块加载进来，逐个块轮询，找到目标并返回。这种方式普遍比较慢。很多情况下都要避免全表扫描情况的发生，所以数据库引入更高效的机制，即索引。关键信息和查找信息的方式组成索引，通过索引可以大幅提升查询速度。）
        2. 什么样的信息能成为索引？
            1. 主键、唯一键、普通键（把记录限定在一定查找范围内的字段，主键便是一个很好的切入点，其他包括唯一键、普通键等也可以作为索引。）
        3. 索引的数据结构？
            1. 生成索引，建立二叉查找树进行二分查找。
            2. 生成索引，建立B-Tree结构进行查找。
            3. 生成索引，建立B+-Tree结构进行查找。
            4. 生成索引，建立Hash结构进行查找。（让查询变得高效的数据结构，如二叉查找树和二叉查找树的变种平衡二叉树、红黑树、BTree、B+Tree以及Hash结构。MySQL数据库索引是通过B+Tree实现。）
        4. 索引的分类？
            1. 主键索引（列值唯一，表中只有一个）、唯一索引（列值唯一）、普通索引、全文索引、联合索引
            2. 创建索引
                ```sql
                -- 直接创建索引
                -- 创建唯一索引
                CREATE UNIQUE INDEX index_name ON table_name(col_name);
                -- 创建普通索引
                CREATE INDEX index_name ON table_name(col_name);
                -- 创建唯一组合索引
                CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);
                -- 创建普通组合索引
                CREATE INDEX index_name ON table_name(col_name_1,col_name_2);
                
                -- 通过修改表结构创建索引
                ALTER TABLE table_name ADD INDEX index_name(col_name);
                
                -- 创建表的时候直接指定
                CREATE TABLE mytable(
                    id INT NOT NULL, 
                    username VARCHAR(16) NOT NULL, 
                    INDEX [indexName] (username(length))
                );
                ```
            3. 删除索引
                ```sql
                -- 直接删除索引
                DROP INDEX index_name ON table_name;
                -- 修改表结构删除索引
                ALTER TABLE table_name DROP INDEX index_name;
                ```
            4. 查看索引
                ```sql
                -- #查看:
                show index from `表名`;
                -- #或
                show keys from `表名`;
                ```
            5. 其他命令
                ```sql
                -- 查看表结构
                desc table_name;
                -- 查看生成表的SQL
                show create table table_name;
                ```
2. 优化你的索引-运用二叉查找树 (05:02)
    1. 二叉查找树
        1. 每个节点最多有两个子树的树结构，通常子树被称为左子树或右子树。
        2. 左子树节点的值均小于根节点，右子树节点的值均大于根节点（注意索引的存储块和数据库的最小存储单位块或者页并非一一对应，为了方便理解先一一对应起来）。
        3. 每个存储块存储的是**关键字和指向子树的指针**。平衡二叉树任意一个节点的左子树和右子树高度差不超过1。
    2. 查询时间复杂度O（logn），查询效率高。
        1. 极端情况（节点全部在左子树或右子树上）时间复杂度将为O（n）。
        2. 可以利用树的旋转的特性保持树为平衡二叉树。
        3. 但还有另一个问题，影响程序运行速度的瓶颈是IO。
        4. 如果假定索引块在磁盘中，找索引会先发生一次IO，将数据读入内存中，之后再发生IO继续查找，直到找到。
        5. 检索深度每增加1，就发生一次IO。平衡二叉树、红黑树等每个节点只能有两个孩子。
        6. 为了组织起数据块，树的深度很深，IO的次数也会很多，检索性能没法满足优化查询需求。
        7. 即降低查询的时间复杂度，又降低IO的次数，要让树每个节点能承受的数据多一些，即利用B-Tree、B+-Tree。
3. 优化你的索引-运用B树 (08:50)
    1. B树
        1. 即平衡多路查找树。
        2. 每个节点最多有m个孩子，这样的树即为m阶B树。
        3. 每个存储块主要**包含关键字和指向孩子的指针**
        4. 最多能有几个孩子取决于每个存储块的容量和数据库的相关配置（通常情况下m是很大的）。
    2. 特征：（案例，三阶B树）
        1. 根节点至少包括两个孩子。
        2. 树中每个节点最多含有m个孩子（m>=2，m<=3）。
        3. 除根节点和叶节点外，每个节点至少有ceil（m/2）个孩子。ceil向上取整
        4. 所有叶子节点位于同一层。
        5. 假设每个非终端节点中包含有n个关键字信息，其中：
            1. Ki（i=1...n）为关键字，且关键字按顺序升序排序K(i-1)<K(i)。
            2. 关键字的个数n必须满足：[ceil(m/2)-1]<=n<=m-1。（任意节点的关键字个数上限比它的孩子数上限少一个，且对于非叶子节点来说，任何一个节点的关键字个数比指向孩子的指针数少一个）
            3. 非叶子节点的指针：P[1]，P[2]...P[M]，其中P[1]指向关键字小于K[1]的子树（某节点最左边孩子节点关键字的值均小于该节点最左边关键字的值），P[M]指向关键字大于K[M-1]的子树（某节点最右边孩子节点的关键字的值均大于该节点里所有关键字的值），其他P[i]指向关键字属于（K[i-1]，K[i]）的子树（某节点其余孩子节点关键字的值的大小均位于离该孩子节点指针最近的两个关键值之间）。
    3. 查找效率和二叉查找树一样，为O（logn）。B树通过合并、分裂、上移、下移节点保持特征，使树比二叉树矮，数据不断变动后不会变成线性的。
    4. B树示例：![20220829155846](https://raw.githubusercontent.com/HITlittlefox/pictures/master/images/20220829155846.png)

4. 优化你的索引-运用B+树 (07:00)
    1. B+树
        1. 是B树的变体，其定义基本与B树相同，除了：
        2. 非叶子节点的子树指针与关键字个数相同。（B+树能存储更多的关键字）
        3. 非叶子节点的子树指针P[i]，指向关键值（K[i],K[i+1]）的子树。（K[i]指向的子树，均小于关键字K[i+1]的值）
        4. 非叶子节点仅用来索引，数据都保存在叶子节点中。（B+树所有的检索都是从根部开始，检索到叶子节点结束，非叶子节点仅存储索引不存储数据，能存储更多的数据。B+树相对B树更矮。B树的搜索可能在任何一个非叶子节点就终结掉了。）
        5. 所有叶子节点均有一个链指针指向下一个叶子节点并按大小顺序链接。（支持范围统计，即定位到某个叶子节点便可以从该叶子节点开始横向跨子树统计。）
    2. B+树示例：![20220829155922](https://raw.githubusercontent.com/HITlittlefox/pictures/master/images/20220829155922.png)
    3. B+树更适合用来做存储索引：
        1. B+树的磁盘读取代价更低（B+树内部结构没有指向关键字具体信息的指针，不存放数据，只存放索引信息。内部节点相对B树更小。如果把所有内部节点的关键字存放在同一盘块中，盘块能容纳的关键字数量也越多，一次性读入内存查找的关键字也就越多，相对来说IO读写次数低）。
        2. B+树的查询效率更加稳定（内部节点不是指向文件内容的节点，只是叶子节点中关键字的索引，任何节点的查找必须有一条从叶子节点到根节点的路，所有关键字查询的长度相同，每个数据的查询时间相同，O(logn)）。
        3. B+树更有利于对数据库的扫描（B+树只需要遍历叶子节点就可以解决对全部数据的扫描）。
    4. **数据库选择B+树作为主流索引数据结构**
5. 优化你的索引-运用Hash以及BitMap (07:09)
    1. 根据Hash函数的运算只需1次定位便能找到需要查询数据所在的头。
        1. Hash索引的查询效率理论上高于B+树索引。
        2. 缺点：
            1. 仅仅能满足“=”，“IN”，不能使用查询范围。（Hash索引比较的是进行Hash运算后的Hash值，只能用于等值的过滤，不能用于基于范围的查询，因为经过相应的Hash算法处理过的Hash值的大小关系不能保证和Hash运算前的完全一样。）
            2. 无法被用来避免数据的排序操作。
            3. 不能利用部分索引键查询。（对于组合索引，Hash索引在计算Hash值的时候是组合键，将键组合合并后在一起计算Hash值，而不是单独计算Hash值。通过组合索引的前一个或几个索引键进行查询时Hash索引也无法被利用。B+树支持利用组合索引中的部分索引。）
            4. 不能避免表扫描。（Hash索引是将索引键通过Hash运算后将运算结果的Hash值和所对应的行指针存放在一个Backet中，不同的索引键具有相同的Hash值，所以取出满足某个Hash键值的数据也无法从Hash索引中直接完成查询，还是需要访问Backet中的数据进行比较。）
            5. 遇到大量Hash值相等的情况性能并不一定会比B树索引高。
    2. BitMap位图索引
        1. 当表中的某个字段只有几种值的时候，在该字段上实现高效统计用位图索引是最佳的选择。目前很少数据库支持位图索引，已知比较主流的是Oracle。位图索引的结构类似B+树。在存储方式上会先按照状态值分开，每种值的空间存放每个实际的数据行是否是这个值。因为只需要存放是与否，所以只需要一个Bit位存放。理论上一个叶子块可以存放非常多的Bit位来表示不同的行。
        2. 缺点：
            1. 锁的密度非常大，当尝试新增或修改数据时，与它在同一个位图的数据操作都会被锁住。因为某行所在的位置顺序会因为数据的添加或者删除而发生改变。
            2. 不适合高并发的联机事务处理系统，即常见的OLTP系统。而适合并发较少，统计数据较多的OLAP系统。
6. 密集索引和稀疏索引的区别 (07:46)
    1. 密集索引文件中的每个搜索码值都对应一个索引值。
        1. （叶子节点不仅保存键值，还保存了位于同一行记录里的其他列的信息。密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。）
    2. 稀疏索引文件只为索引码的某些值建立索引项。
        1. （叶子节点仅保存键位信息和该行数据的地址，有的稀疏索引仅保存键位信息及其主键。定位到叶子节点仍需要地址或主键信息进一步定位到数据。）
    3. 图![20220829170205](https://raw.githubusercontent.com/HITlittlefox/pictures/master/images/20220829170205.png)
    4. MySQL常见的两种的存储引擎：
        1. MyISAM：主键索引、唯一键索引、普通索引其索引均属于稀疏索引
        2. InnoDB：必须有且仅有一个密集索引，密集索引的选取规则如下：
        3. 若一个主键被定义，则该主键作为密集索引。
        4. 如果没有主键被定义，该表的第一个唯一非空索引则作为密集索引。
        5. 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）。
        6. 非主键索引存储相关键位和其对应的主键值，包含两次查找。（非主键索引即稀疏索引的叶子节点不存储行数据的物理地址，而是存储的该行的主键值，所以非主键索引包含两次查找，一次查找次级索引自身，再查找主键。见下图左）
7. 索引额外的问题之如何调优Sql (25:39)
3-7,3-8都没看.
8. 索引额外问题之最左匹配原则的成因 (07:44)
9. 索引额外问题之索引是建立越多越好吗 (01:25)**不是**。  
    1. 数据量小的表不需要建立索引，建立会增加额外的索引开销。
    2. 数据变更需要维护索引，因此更多的索引意味着更多的维护成本。
    3. 更多的索引意味着需要更多的空间。
10. 锁模块之MyISAM与InooDB关于锁方面的区别 (19:00)
11. 锁模块之MyISAM与InooDB关于锁方面的区别_2 (20:38)
12. 锁模块之数据库事务的四大特性 (02:23)

13. 锁模块之事务并发访问产生的问题以及事务隔离机制 (16:10)

14. 锁模块之事务并发访问产生的问题以及事务隔离机制_2 (15:57)

15. 锁模块之当前读和快照读 (20:54)

16. 锁模块之RR如何避免幻读 (23:03)

17. 锁模块小结 (01:08)

18. 关键语法讲解 (23:09)

19. 本章总结 (02:04)

20. 彩蛋之面试的三层架构 (10:53)

21. 是什么机制能让它"恰好"避免幻读呢？