---
title: 二叉树的递归套路
category: 大三下
date: 2022-07-08 08:56:31
tags:
---
## 二叉树的递归套路
1. 简述
    1. 可以解决面试中的绝大部分二叉树(95%以上)的问题，尤其是树形dp问题
    2. 其本质是利用递归遍历二叉树的便利性，每个节点在递归的过程中可以回到该节点3次
2. 具体步骤为：
    1. 假设以X节点为头，假设可以向X左树和右树要任何信息
    2. 在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（最重要）
        1. **常见分类**
            1. 与X无关的答案
            2. 与X有关的答案
    3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
    4. 把左树信息和右树信息**求全集**，就是任何一颗子树都需要返回的信息S
    5. 递归函数都返回S，每颗子树都这么要求
    6. 写代码，在代码中考虑如何把左树信息和右树信息整合出整棵树的信息
3. Base cases: 
    1. The base case is also called **a stopping condition for recursive calls**. It is very important to have a base case for every recursive code.

### 给定一棵二叉树的头结点head，返回这颗二叉树是不是平衡二叉树
1. `Code03_IsBalanced`
2. 题目解释:
    1. 平衡树概念：在一棵二叉树中，每一个子树，左树的高度和右树的高度差不超过1
3. **以X为头的树的可能性**，要做到平衡，需要的条件是
    1. X左树平衡，
    2. 右树平衡，
    3. X的左树高度和右树高度差不超过1
    4. 对左树的要求:
        1. 返回:是否平衡
        2. 返回:高度
    5. 对右树的要求:
        1. 返回:是否平衡
        2. 返回:高度
4. 如果想用递归,需要左右都索要相同信息**求全集**,也就是他们给的信息的**并**,所以该题,我们X需要向左右子树要的信息Info为，
    1. 是否平衡public boolean isBalanced;
    2. 高度public int height;
```java
// 左右要求一样，Info信息返回的结构体
public static class Info {
    public boolean isBalanced;
    public int height;

    public Info(boolean i, int h) {
        isBalanced = i;
        height = h;
    }
}
```

```java
public static Info process(Node x) {
    if (x == null) {
        return new Info(true, 0);
    }
    // 假设左树可以给信息
    Info leftInfo = process(x.left);
    // 假设右树可以给信息
    Info rightInfo = process(x.right);
    // 整棵树的高度
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    // 该树是否平衡，先假设true，再用条件进行判断
    boolean isBalanced = true;
    if (!leftInfo.isBalanced) {
        isBalanced = false;
    }
    if (!rightInfo.isBalanced) {
        isBalanced = false;
    }
    if (Math.abs(leftInfo.height - rightInfo.height) > 1) {
        isBalanced = false;
    }
    return new Info(isBalanced, height);
}
```

### 返回二叉树任意两个节点最大值
1. `Code06_MaxDistance`
2. 题目解释:
    1. 给定一棵二叉树的头结点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离
    2. 两个节点之间的距离:两个节点中最精简的路径上存在的节点数
3. **以X为头的树的可能性**(常见的分类)
    1. 有可能最大距离和当前节点X无关(最大距离不通过X)
        1. 最大距离是X左树的最大距离,或者,右树的最大距离
        2. 需要选出max(左树最大距离,右树最大距离)
    2. 最大距离跟X有关，
        1. 即最大距离通过X
        2. 左树离X最远的点,到,X右树上离X最远的点。
        3. 即X左树的高度,加上,X自身高度1,加上,X右树上的高度
    3. 对左树的要求:
        1. 返回整棵树最大距离
        2. 返回高度
    4. 对右树的要求:
        1. 返回整棵树最大距离
        2. 返回高度
4. 结论：根据递归套路，我们每次递归，需要返回X左树的最大距离和高度，同理返回X右树的最大距离和高度。
5. **Info求并集**
    1. 最大距离
    2. 高度

## 返回二叉树中的**最大**的搜索二叉树Size
1. `Code05_MyMaxSubBSTSize`
2. 题目解释:
    1. 给定一颗二回这颗二叉树中最大的二叉搜索树的Size
    2. 搜索二叉树概念：整颗树上没有重复值，左树的值都比我小，右树的值都比我大。每颗子树都如此。
3. **以X为头的树的可能性**(常见的分类)
    1. 与X无关
        1. 最终找到的搜索二叉树，不以X为头
        2. 左树满足搜索二叉树的大小/节点个数
        3. 右树满足搜索二叉树的大小/节点个数
    2. 与X有关
        1. 最终找到的搜索二叉树，以X为头
        2. X的左树整体是搜索二叉树
        3. X的右树整体是搜索二叉树
        4. 左树的最大值 小于 X
        5. 右树的最小值 大于 X
4. 列出需要信息:
    1. 左树
        1. 最大搜索二叉树的子树的大小size
        2. 左树整体是不是搜索二叉树 isAllBST
        3. 左树最大值
    2. 右树:
        1. 最大搜索二叉树的子树的大小size
        2. 右树整体是不是搜索二叉树 isAllBST
        3. 右树最小值
5. 总结Info
    1. size
    2. isAllBST
    3. max
    4. min

### 派对最大快乐值
1. Code04_MaxHappy
    排队最大快乐值问题，员工信息定义如下，多叉树结构：
    ```java
    class Employee{
        // 这名员工可以带来的快乐值
        public int happy;
        // 这名员工有哪些直接的下级
        List<Employee> subordinates;
    }
    ```
2. 题目解释:
    1. 每个员工都符合Employee类的描述，整个公司的人员结构可以看作是一颗标准的，没有环的多叉树。
    2. 树的头结点是公司唯一的老板。除了老板外的每个员工都有唯一的直接上级。
    3. 叶节点是没有任何下属的基层员工（subordinates为空），除了基层员工股外，每个员工都有一个或多个直接下级。
    4. 现在公司要来办party，你可以决定哪些员工来，哪些员工不来，
    5. 规则:
        1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
    6. 排队的整体快乐值是所有到场员工的快乐值的累加
    7. 你的目标:
        1. 让派对的整体快乐值尽量的大
    8. 给定一颗多叉树头结点boss，请返回排队的最大快乐值
3. **以X为头的树的可能性**(常见的分类)(假设X有三个员工,分别为firstChild,secondChild,thirdChild)
    1. X不来
        1. 0
        2. max{firstChild**来**的最大快乐值,firstChild**不来**的最大快乐值,}
        3. max{secondChild**来**的最大快乐值,secondChild**不来**的最大快乐值,}
        4. max{thirdChild**来**的最大快乐值,thirdChild**不来**的最大快乐值,}
        5. 相加
    2. X来
        1. X.happy
        2. X.firstChild **不来**的情况下:整棵树的快乐值
        3. X.secondChild **不来**的情况下:整棵树的快乐值
        4. X.thirdChild **不来**的情况下:整棵树的快乐值
        5. 相加
4. Info:
    1. X**来**的情况下,整棵树的最大快乐值
    2. X**不来**的情况下,整棵树的最大快乐值