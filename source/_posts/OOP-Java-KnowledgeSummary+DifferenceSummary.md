---
title: OOP-Java-KnowledgeSummary+DifferenceSummary
category: Java
date: 2021-11-01 21:30:29
tags:
---

<!-- todo：1~7的课本代码 -->
<!-- doing：整理1~7知识点+**区别**，todo：补充ppt知识点 -->
## 1
1. Java语言的九大特点p1
   1. 简单、面向对象、平台无关、分布、可靠、安全、多线程、网络编程、编译+解释
2. Java程序的运行过程p3
   1. 先编译后解释
   2. 开发与运行Java程序需要经过的三个主要步骤为“编辑源程序”、“编译生成字节码”、“解释运行字节码”。
3. *Java应用程序与Java小程序的**区别**：*
   1. 小程序和应用程序之间的技术差别在于运行环境。
   2. 由于小程序和应用程序的执行环境不同，它们的最低要求也不同。在应用方面，WWW使小程序的发布十分便利，因此小程序更适合在Internet上使用；相反，非网络系统和内存较小的系统更适合使用Java应用程序。
   3. Java 小程序可以直接利用浏览器或appletviewer 提供的图形用户界面，而Java应用程序则必须另外书写专用代码来营建自己的图形界面。
   4. 小程序的主类（程序执行的入口点）必须是一个继承自系统类Applet的子类，且该类必须是public类。
---
## 2
---
## 3
1. *基本数据类型和引用数据类型的**区别**p17*
   1. 前者在内存中存放数据值
   2. 后者在内存中存放指向该数据的地址
2. 标识符的规定p20
   1. 字母、数字、下划线、美元符号
   2. 字母、下划线、美元符号开头，不可以用数字开头
3. 命名习惯p20
   1. **类名首字母大写**
   2. **变量、方法及对象首字母小写**
   3. **Java中包名使用小写字母表示**
4. 程序中使用常量的两点好处p21
   1. 可读性
   2. 可维护性
5. 使用变量的原则p22
   1. 先声明后使用
6. 数据类型转换的2方式 p23两个小标题
   1. 数值型不同类型数据的转换：自动、强制
   2. 字符串型数据与整型数据相互转换parse、+
7. 数值型数据自动类型转换的条件p23
    1. 转换前后类型兼容
    2. 后比前大
8. Java语言对+运算符的拓展p32：字符串连接
9. 浮点数之间不能做“==”的比较p33：有误差
10. 简洁与&&、简洁或||p33
    1. &&两个操作数均为true，结果才为true，如果左边false，直接false
    2. ||两个操作数均为false，结果才为false，如果左边true，直接true
11. 异或运算一句话p33：
    1. 两个值不同，值为真；
    2. 两个值相同，值为假
12. *简洁运算(&&、||)与非简洁运算(&、|)的**区别**在于：*
   >1. 非简洁运算在必须计算完左右两个表达式之后，才取结果值；
   >2. 而简洁运算可能只计算左边的表达式而不计算右边的表达式，
   >3. 即对于&&，只要左边表达式为false，就不计算右边表达式，则整个表达式为false；
   >4. 对于||，只要左边表达式为true，就不计算右边表达式，则整个表达式为true。
13. 编码习惯：
    1. **类名首字母大写**
    2. **变量、方法及对象首字母小写**
    3. **Java中包名使用小写字母表示**
---
## 4
1. 三种基本流程结构p39：顺序、分支、循环
2. Java三种循环语句p45：while、do-while、for
3. *do-while和while的**区别**p48*
   1. do-while:先执行一遍循环体，再来判断条件表达式的值，若真，则继续，否则跳出
   2. do-while特点：循环体至少被执行过一次
   3. while:先计算条件表达式的值
4. Java三种无条件转移语句p53
   1. break
   2. continue
   3. return
5. *break和continue和return的**区别**p54*
   1. break强行跳离switch或循环，转去执行下一条语句
   2. continue强行跳到循环开始处执行下一轮循环
   3. return使程序从方法中返回
---
## 5
1. Java两种内存p56
   1. 栈内存
   2. 堆内存
2. 数组3特点p57
   1. 相同数据类型元素的集合
   2. 各元素有先后顺序，按顺序连续存放在一起
   3. 数组元素用整个数组的名字和自己再数组中的顺序位置来表示
3. 使用数组3步骤p57
   1. 声明数组
   2. 分配空间
   3. 创建数组元素并赋值
4. *堆内存和栈内存的**区别***
   1. 栈内存：**定义的基本类型的变量**和**对象的引用变量**，超出作用域将自动释放。
   2. 堆内存：存放由new运算符创建的**对象**和**数组**。由Java虚拟机的自动垃圾回收器来管理。
---
## 6
1. OOP最核心的概念p73
   1. 类和对象
2. 类修饰符p75
   1. public公共类在所有类中可见，在其他包中可以用import导入。
   2. abstract抽象类，不能新建对象
   3. final最终类，表示该类不能被继承
   4. 缺省:没有修饰符，在同一个包中的类中可见，在其他包中不能用import导入。
3. 成员变量修饰符p75
   1. public在任何类中可见
   2. private只在本类中可见，子类中也不可见
   3. protected在子类中或同一个包中可见
   4. 缺省:在同一个包中可见，子类不在一个包中，子类中也不可见  
   5. final常量，定义后不能修改
   6. static静态变量，被类的所有实例共享
   7. transient告诉编译器，在类对象序列化的时候，此变量不需要持久保存
   8. volatile指出可能有多个线程修改此变量，要求编译器优化以保证对此变量的修改能够被正确的处理
4. 成员方法修饰符p76
   1. public在任何类中可见
   2. private只在本类中可见，子类中也不可见
   3. protected在子类中或同一个包中可见
   4. 缺省:在同一个包中可见，子类不在一个包中，子类中也不可见
   5. final最终方法，所有子类不能覆盖该方法，但可以重载
   6. static静态方法，并不需要创建类的实例就可以访问静态方法
   7. abstract抽象方法，在抽象类中没有实现的方法
   8. synchronized在多线程中，synchronized方法调用时，其他所有方法不能调用该方法
   9. native本地方法，外部编写
5. *成员变量和局部变量的**区别**p77*
   1. 类中定义成员变量、方法中定义局部变量
   2. 语法：
      1. 成员变量属于类，局部变量属于方法
      2. 成员变量可以被public、private、static修饰，局部变量不能被访问控制修饰符及static修饰
      3. 都可以被final修饰
   3. 存储方式：成员变量跟着对象存放在堆；局部变量存在于栈
   4. 内存中的生存方式：成员变量随着对象创建而存在；局部变量随着方法调用而产生，方式结束而消失
   5. 自动赋值**区别**：成员变量自动赋值；局部变量必须显式赋值
6. 创建对象的步骤p78
   1. 声明指向由类所创建的对象的变量
   2. 利用new运算符创建新的对象，并指派给前面所创建的变量
7. 一个对象的生命周期p77
   1. 创建、使用、销毁
8. 使用匿名对象的情况p88
9.  *使用匿名对象的情况：*
   1. **如果对一个对象只需要进行一次方法调用。**
   2. **将匿名对象做为实参传递给一个方法调用。**
---
## 7
1. 方法重载的定义p95
   1. 同一类内定义多个名称相同的方法，然后根据其参数的不同（参数个数、参数类型）来设计不同的功能，以适应编程的需要
2. 构造方法的特殊性p96
   1. 方法名=类名
   2. 无返回值，不能写void
   3. 作用：完成类对象的初始化
   4. 不能显示调用，而是使用new调用
   5. 自动调用构造方法为新对象初始化
3. *静态成员(类成员)和实例成员的**区别**p101*
   1. 前者被static修饰、隶属于类、可被`类名.静态变量名`调用
   2. 后者不被static修饰，属于对象
4. 静态方法的含义p104
   1. 被static修饰、属于类
   2. 不能访问实例变量与实例方法
   3. 不能用this或super
   4. 类名.静态方法名(); 对象名.静态方法名();
5. *静态初始化器和构造方法的**区别**p106*
   1. 初始化对象不同
   2. 执行时间不同
   3. 调用次数不同
   4. 性质不同（静态初始化器不是方法）
6. 用数组存放对象的步骤p110
   1. 声明数组，new分配空间
   2. 创建对象，分配内存空间，并让数组元素在指向它
7. 垃圾回收的好处p112
   1. 从复杂的内存追踪、监测、释放工作中解放程序员
   2. 防止内存非法释放，提高系统稳定性
8. 垃圾回收的特点p112
   1. 对象不被引用类型变量使用时，才被回收
   2. 不能强迫回收
   3. 先finalize()方法
9.  实例变量：**没有static修饰**的变量
10. 静态变量（也叫类变量）:声明时需**加static修饰符**
11. `成员变量(静态变量、类变量)与局部变量（实例变量）的`****区别****
   4. 从语法形式上看，**成员变量属于类**，而**局部变量是方法中定义的变量或方法的参数**；
   5. 再从语法形式上看，**成员变量可以被public、private和static等修饰**，**而局部变量则不能**，**二者都可以被final修饰**。
   6. 从变量在内存中的存储方式看，**成员变量是对象的一部分，对象是存储在堆内存的**，**局部变量存于栈**。
   7. 从变量在内存中的生存时间上看，**成员变量是对象的一部分，它随着对象的创建而存在**；**局部变量随着方法的调用而产生，随着方法调用的结束而消失**。
   8. **成员变量若没有被赋初值，则自动初始化默认为0**（用final修饰的但没有被static修饰的成员变量必须显式赋值）；**局部变量不会自动赋值，必须显式赋值**。
12. **实例方法：声明时前面不加static修饰符;**
13. **静态方法：表示类中对象的共有行为，声明时前面需加static修饰符；**
14. *静态初始化器与构造方法**区别***：
    1. 初始化对象不同：构造方法是对每个新创建的**对象**初始化，而静态初始化器对整个**类**自身进行初始化，包括static成员变量赋初值。
    2. 执行时机不同：构造方法是在用new创建新对象时由系统自动执行，而静态初始化器一般不能由程序来调用，它是在所属的类被加载入内存时由系统调用执行。
    3. 执行次数不同：用new创建多少个新对象，构造方法就调用多少次，但静态初始化器则在类被加载入内存时只执行一次。
    4. 静态初始化器不是方法，它没有方法名、返回值和参数。
    5. 如果有多个静态初始化器，则它们在类的初始化时会依次执行。
---
## 8
1. java子类自动调用父类的无参构造方法的目的p117 p151
   1. 初始化继承父类的成员
2. 怎样在子类中调用父类构造方法`super()`p119
3. 覆盖overriding的定义p121
   1. 在子类中定义名称、参数个数、类型均和父类中完全相同的方法，用来重写父类中同名方法。
4. 通过父类对象访问子类方法的条件p124
   1. 只限于“覆盖”情况发生
5. 最终类的概念p125
   1. 被final修饰符修饰，不能被其他类继承，不能有子类
6. “即是”原则p128
   1. 所有类都是Object类的子类，根据即是原则，所有类的对象即是Object类的对象。
7. 抽象类定义p130
   1. abstract修饰，不能创建实例对象，能被继承
   2. tips：
      1. 包含抽象方法的类一定是抽象类
      2. 抽象类中不一定有抽象方法
      3. 子类必须实现父类的所有抽象方法，才能产生对象
8. *接口与抽象类的**区别**p132*
   1. 接口中所有数据成员都是静态且必须初始化，都是静态常量
   2. 接口有抽象方法、可以有静态方法、默认方法
9.  接口特点p133
    1. 抽象方法只需要声明，不需要方法体
    2. 数据成员必须是静态常量
    3. 都是公共成员，所以省略public，实现抽象方法时，不能省略public
    4. 接口是一种特殊的抽象类
10. 接口命名惯例p133TODO:
    1. 接口中的常量通常都使用大写字母命名
11. 接口的实现的定义p133
    1. 利用接口创建新类的过程
12. 类实现接口需要注意的问题p134
    1. 如果实现接口的类不是抽象类，则需要实现指定接口的所有抽象方法。
    2. 实现接口的抽象方法的时候，需要完全相同的方法头。
    3. public
    4. 每个接口都被编译成独立的.class文件
13. 接口可以作为一种引用类型p134
    1. 可以声明接口类型的变量或数组，并用它来访问实现该接口的类的对象
14. *接口与继承的**区别**p135*
    1. 一个接口可以有一个以上的父接口，他们之间用逗号分隔，形成父接口列表。
    2. 新接口将继承父接口中的常量、抽象方法、默认方法，但是不能继承父接口中的静态方法，也不能被实现类所继承。
    3. 只能最多继承一个父类，不能多重继承。
15. 单继承性的优点p137
    1. 结构简单、层次清楚、易于管理、更安全可靠
16. 接口主要作用p137
    1. 帮助实现类似于类的多重继承功能
17. Java如何实现多重继承p137
    1. 一个类实现多个接口，implements中用逗号分隔各个接口名，如果把接口理解为特殊的类，那么这个类利用接口就获得了多个父类，实现了多重继承
18. 在多个父接口的实现类中，如何解决同名默认方法p140
    1. tips静态方法不能被继承，默认方法可以被继承
    2. 提供同名方法的一个新实现
    3. 委托一个父接口的默认方法
19. *枚举类与普通类的**区别**p141*
    1. 枚举可实现接口，不可显式继承父类
    2. 枚举默认final
    3. 不能new
    4. private
    5. 所有枚举成员必须在枚举体第一行显式列出
20. p151
21. this()和super()的相似之处   
    1. 如果构造方法有重载，两者都可以根据所给予的参数类型和个数，正确执行对应构造方法
    2. 都需要第一行
22. protect()的好处
    1. 兼顾安全与便利性
23. *重载与覆盖的**区别***
    1. 重载：同一类内定义多个名称相同的方法，然后根据其参数的不同（参数个数、参数类型）来设计不同的功能
    2. 覆盖：在子类中定义名称、参数个数、类型均和父类中完全相同的方法，用来重写父类中同名方法。
24. 父类方法如何不被覆盖：final
25. 变量怎么变常量：final
26. 所有类都继承自？Object
27. 抽象类的目的：要用户根据他的格式来修改并创建新的类
28. 抽象类中的2类方法
    1. 一般方法
    2. 抽象方法
29. *接口与抽象类的**区别***
    1. 接口的数据成员都是静态且初始化
    2. 接口抽象方法必须都是public abstract
30. Java如何实现多重继承
31. 枚举类型名的2层含义
    1. 枚举名
    2. 枚举数据类型
32. 如何访问不同package下的类？
    1. 目标类public
    2. 正确路径
33. 怎么导入包里的某个类？
    1. import 包名.类名
34. **覆盖:指在子类中，定义名称、参数个数与类型均与父类完全相同的方法，用以重写父类里同名方法的功能**
35. **重载:是指在同一个类定义名称相同，参数列表不同的方法。**
36. *接口与抽象类非常相似，**区别**：*
    1. 接口的数据成员都是静态常量；
    2. 接口中除了抽象方法外，还可以定义**默认方法**和**静态方法**，但不能有普通方法。
37. *接口继承与类继承的**区别**：*一个接口可以有一个以上的父接口，它们之间用逗号隔开，形成父接口列表。
38. *StringBuilder与StringBuffer**区别***
    1. 两者最大的不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。
    2. StringBuilder 有速度优势，所以多数情况下建议使用 StringBuilder 类。
    3. 在应用程序要求线程安全的情况下，必须使用 StringBuffer 类。
---
## 9
1. 按错误的性质可将程序错误分为3类 p154 语法错、语义错、逻辑错
2. 根据错误严重程度的不同，把错分为两类：p154 错误和异常
3. Java通过什么处理异常？什么是抛出异常？什么叫捕获异常？p154
   1. 通过Java异常处理机制处理异常
   2. **抛出异常**：**产生一个代表该异常的对象，并把它提交给运行系统的过程**（异常对象可由应用程序本身产生，也可能由JVM产生）。
   3. **捕获异常**：**异常抛出后，运行系统从生成异常对象的代码开始，沿方法的调用栈逐层回溯查找，直到找到包含相应异常处理的方法，并把异常对象提交给该方法为止，这个过程称为捕获(catch)异常。**
4. 什么是Java语言异常处理机制？p155
   1. **Java异常处理机制**：**每当Java程序运行过程中产生一个可识别的运行错误时，系统都会产生一个相应的该异常类的对象。一旦一个异常对象产生了，系统中就一定有相应的机制来处理它，从而保证整个程序运行的安全性。**
5. 异常处理3步骤？p155
   1. “抛出”一个异常，
   2. 运行系统“捕获”该异常，
   3. 并交由程序员编写的相应代码进行异常处理。
6. 异常类的层次结构图？p156
7. 程序对错误与异常的3种处理方式？p157
   1. **程序不能处理的错误，交操作系统处理**；
   2. **程序应避免而可以不去捕获的运行时异常（RuntimeException）**
   3. **必须捕获（使用try-catch-final）的非运行时异常**。
8. 捕获异常的意义所在p157
   1. 需要能让程序来接收和处理异常对象，从而不会影响其他语句的执行
9.  多异常处理的定义p158
    1. **通过一个try块后面定义若干catch块来实现的，每个catch块用来接收和处理一种特定的异常对象**
10. 抛出异常的分类p161
   1. 系统自动抛出的异常
   2. 指定方法抛出异常
   3. 所有系统定义的运作时异常都可以由系统自动抛出，指定方法抛出异常需要使用关键字throw或throws来明确指定在方法内抛出异常。
11. 抛出异常的方法、处理异常的方法p161
    1. 在方法体内使用throw语句抛出异常对象
    2. 在方法头部添加throws子句表示方法将抛出对象
12. 自动资源管理语句p167try-with-resources
13. 自定义异常类的作用p168
14. 对异常处理的方式p169
15. p170
16. 异常发生时的2种处理方式
17. 默认异常处理机制
18. try-catch-finally步骤
19. 检查型异常和非检查型异常的**区别**
20. 抛出异常的两种方式
---
## 10
1. 按照数据的传输方向，流可分为输入流和输出流
2. 流式输入输出的最大特点p173
   1. 数据的获取和发送是沿着数据序列顺序进行的
3. 缓冲流的目的p173
   1. 提高数据的传输效率
4. 缓冲区是怎么运作的？p173
   1. 写入数据时，先发送数据到缓冲区，满了后再一起发送到外部设备
   2. 读取数据时，从缓冲区读取数据
5. 根据输入输出数据类型的不同，输入输出流按处理数据的类型分为两种：字节流和字符流
6. 字节流和字符流的**区别**p174
   1. 字符流：针对字符数据特点优化
7. 输入输出流的类层次结构图p175
8. 处理字节流的类和处理字符流的类
9.  p197
10. 流的好处
    1. 无论是什么形式的输入输出，只要针对流进行处理就可以了。
11. BufferedWriter.newLine()
12. File对象
13. 随机访问文件类是什么RandomAccessFile
14. BufferedReader从键盘读入信息用一行表达式实现：
      ```java
      //从键盘读入信息
      BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
      ```
15. BufferedWriter写入，用一行表达式实现：
      ```java
      //BufferedWriter写入
      BufferedWriter out = new BufferedWriter(new FileWriter(fileName));
      ```
16. BufferedReader从文件读取，一行表达式实现：
      ```java
      //BufferedReader读取方法：
      BufferedReader bfr = new BufferedReader(new FileReader(fileName)); 
      ```
17. <!-- TODO:文本文件的复制-->
---
## 11
1. 多线程的主要目的p199
   1. 将一个程序中的各个“程序段”并发化。
2. 什么是多线程？p199
   1. 同一个进程中同时存在几个执行体按几条不同的执行路径同时工作的情况。
3. 多线程编程p199
   1. 将一个程序任务分成几个可以同时并发执行的子任务
4. *线程和进程的**区别**p201*
   1. 进程：资源分配的单位；同一段时间内，可以同时执行一个以上的程序
   2. 线程：处理器调度的基本单位；同意程序内同时执行一个以上的程序段
   3. 各进程是独立的，各线程不一定
5. 多线程是什么？
   1. CPU在同一时间段内执行一个程序中的多个程序段来完成工作
6. *多任务和多线程的**区别**p201*
   1. 多任务是相对操作系统而言的，表示操作系统可以同时运行多个应用程序
   2. 多线程是相对一个进程而言的，表示在一个进程内部可以同时执行多个线程
7. 线程的生命周期与线程的状态(图)p201
   1. 新建、就绪、执行、阻塞、消亡
8. 线程阻塞的条件p202
   1. 调用sleep()或者yield()
   2. 等待一个条件变量，wait()
   3. 被join()
9.  线程消亡的原因p202
    1. 完成工作
    2. 被迫停止
10. 怎么改变线程的优先级？p203
    1. setPriority()
11. 什么是线程的调度？p203
    1. 在各个线程之间分配CPU资源
12. 抢占式调度模型是什么？p203
    1. 一旦活动线程获得执行权，将一直执行，直到执行完或放弃执行权
    2. 一般会时不时进入睡眠状态
13. 实现多线程的方法？p203
    1. 继承Thread类
    2. 实现Runnable接口
14. 继承Thread类激活线程的前置？p204
    1. 继承Thread类
    2. 执行代码写在run()内
15. *run()和start()的**区别**？p205*
    1. run()规定了线程要执行的任务
    2. start()启动线程
16. 两种多线程方法的**区别**？p207
    1. 直接继承Thread类的特点是：
       1. 编写简单，可以直接操纵线程；
       2. 但缺点是若继承Thread类，就不能再继承其他类。
    2. 使用Runnable接口的特点是：
       1. 可以将Thread类与所要处理的任务的类分开，形成清晰的模型；
       2. 还可以从其他类继承，从而实现多重继承的功能
       3. 相比于Thread类，Runnable更适合于多个线程处理同一资源。
       4. 几乎所有多线程应用都可以用实现Runnable接口的方式来实现
       5. 主要**区别**就在于对**数据的共享**上。使用Runnable接口可以轻松实现**多个线程共享相同数据**，只要用同一个实现了Runnable接口的类的对象作为参数创建多个线程就可以了
17. 两种方式的特点？p208
18. *线程异步和同步的**区别**？p212*
    1. 异步执行：包含了运行时所需要的数据或方法的线程，不必关心其他线程的状态或行为，称这样的线程为**独立的、不同步的、异步执行的**。
    2. 线程的同步：当一个线程对共享的数据进行操作时，应使之成为一个“原子操作”，即在没有完成相关操作之前，**不允许其他线程打断它**，否则就会破坏数据的完整性，必然会得到错误的处理结果，这就是**线程的同步**。（处理数据的线程，不能处理其他线程当前还没有处理结束的数据，但是可以处理其他的数据）
19. 什么是线程的同步？p212
20. *同步与共享数据的**区别**？p212*
    1. 共享：线程之间对内存数据的共享
    2. 同步是在共享的基础上，针对多个线程共享会导致数据不一致而提出来的。
    3. 线程之间彼此不独立、需要进行同步控制
    4. 同时运行的几个线程需要共享一些数据
21. 临界资源(同步资源)概念？p214
22. 临界代码(临界区)？p214
23. 互斥锁机制p214
24. synchronized关键字p214
25. synchronized功能p215
    1. 首先判断对象或方法的互斥锁是否存在，若在就获得互斥锁，然后就可以执行紧随其后的临界代码段或方法体；
    2. 如果对象或方法的互斥锁不存在（已被其他线程拿走），就进入等待状态，知道获得互斥锁。
26. 什么时候会自动释放互斥锁？p215
    1. 当被synchronized限定的代码段执行完，就自动释放互斥锁。
27. synchronized特点p216
    1. 临界代码
    2. 越少越好
    3. 可交替穿插
    4. 非同步可自由调用
    5. 一个对象的互斥锁只能被一个线程拥有
    6. 执行完才会释放
    7. 共享变量private
    8. 只能用临界代码方法访问共享变量
28. 线程间通信的方法？及其使用条件？p217
    1. java.lang.Object类的`wait()`、`notify()`、`notifyAll()`等方法为线程间的通信提供了有效手段。
    2. 上三方法只能在同步代码块里调用
29. p219
30. 多任务和多线程的**区别**
31. 创建线程的2方法
32. run()
33. 激活线程前置
34. 线程5状态：新建、就绪、执行、阻塞、消亡
35. 阻塞
36. 解除阻塞
37. sleep()
38. 异步
39. 同步控制
40. 原子操作：线程的同步：当一个线程对共享的数据进行操作时，应使之成为一个“原子操作”，即在没有完成相关操作之前，**不允许其他线程打断它**，否则就会破坏数据的完整性，必然会得到错误的处理结果，这就是**线程的同步**。
41. ****区别**：***两种创建线程对象的方式的特点*：
      >1. 直接继承Thread类的特点是：
      >   1. 编写简单，可以直接操纵线程；
      >   2. 但缺点是若继承Thread类，就不能再继承其他类。
      >2. 使用Runnable接口的特点是：
      >   1. 可以将Thread类与所要处理的任务的类分开，形成清晰的模型；
      >   2. 还可以从其他类继承，从而实现多重继承的功能
      >   3. 相比于Thread类，Runnable更适合于多个线程处理同一资源。
      >   4. 几乎所有多线程应用都可以用实现Runnable接口的方式来实现
      >   5. 主要**区别**就在于对**数据的共享**上。使用Runnable接口可以轻松实现**多个线程共享相同数据**，只要用同一个实现了Runnable接口的类的对象作为参数创建多个线程就可以了
42. **区分***（异步与同步的区分）*
      >1. 异步执行：包含了运行时所需要的数据或方法的线程，不必关心其他线程的状态或行为，称这样的线程为**独立的、不同步的、异步执行的**。
      >2. 线程的同步：当一个线程对共享的数据进行操作时，应使之成为一个“原子操作”，即在没有完成相关操作之前，**不允许其他线程打断它**，否则就会破坏数据的完整性，必然会得到错误的处理结果，这就是**线程的同步**。（处理数据的线程，不能处理其他线程当前还没有处理结束的数据，但是可以处理其他的数据）
43. **区分** *同步与共享数据*
    1. 共享：线程之间对内存数据的共享
    2. 同步是在共享的基础上，针对多个线程共享会导致数据不一致而提出来的。
    3. 线程之间彼此不独立、需要进行同步控制
    4. 同时运行的几个线程需要共享一些数据
---
## 12
1. 运用泛型意味着什么？p222
   1. 编写的代码可以被很多类型不同的对象所重用，从而减少数据类型转换的潜在错误
2. 使用泛型的优点p222
   1. 能够在编译时而不是在运行时检测出错误
3. 类型参数？
4. 泛型的实质？
   1. **数据类型参数化**
5. *自动包装和自动解包p224*
   1. 当编译器发现程序在应该使用`包装类对象`的地方却使用`基本数据类型的数据`时，编译器将自动把`该数据`包装为`该基本类型对应的包装类的对象`，这个过程称为自动包装。
   2. 当编译器发现在应该使用`基本类型数据`的地方却使用了`包装类的对象`，则会把`该包装类对象`解包，从中取出`所包含的基本类型数据`，这个过程称为自动解包。
6. 类型推断什么时候有效？p225、p226
   1. 类型推断只对赋值操作有效。
7. 设计泛型方法的目的p226
   1. 针对具有容器类型参数的方法
8.  *泛型方法和泛型类之间的**区别**p227*
   2. 对于泛型方法，不需要传递实际的类型
   3. 泛型类必须要传递实际的类型
9.  泛型限制的关键字p227
    1. extends
10. 泛型不是协变的p228
    1. 若泛型的实际参数的类之间有`父子关系`时，参数化后得到的泛型类之间并**不会**具有同样的父子类关系，即子类泛型“并不是一种”父类泛型。
11. 通配符“？”的作用p228
    1. 创建可重新赋值但不可修改其内容的泛型对象
    2. 用在方法的参数中，限制传入不想要的类型实参。
12. 使用通配符“？”的条件p228
    1. 只知道通配符“?”表示时`某个类`又或是`继承该类的子类`又或是`实现某个接口的类`，但具体是什么类型不知道。
13. 直接使用通配符<?>创建泛型对象，的2个特点？p230
    1. 具有通用性，即该泛型类的其他对象可以赋值给用通配符`?`创建的泛型对象，因为`?`等价于`? exends Object`，反之不可。
    2. 用通配符`?`创建的泛型对象，只能获取或删除其中的信息，但不可为其添加新的信息。
14. 上限通配、下限通配p230
    1. 上限通配：`? exends Object`中，T被认为是类型参数`?`的上限。
    2. 下限通配：`? super Object`中，T被认为是类型参数`?`的下限，（T或T的一个未知父类型）。
15. 引入通配符的主要目的p230 **支持泛型中的子类，实现多态**
16. *通配符与类型参数的**区别**p230* 
    1. 泛型方法中**类型参数**的优势：可以表达多个参数之间或参数与返回值之间的类型依赖关系。
    2. 如果方法中并不存在类型之间的依赖关系，则可以不使用泛型方法，而选用**通配符**。
    3. **通配符**更清晰、简明，在程序开发过程中建议尽量采用通配符。
17. JVM编译对泛型安全检查的特点p231
    1. 不能使用泛型的类型参数T创建对象。
    2. 在泛型中可以用类型参数T声明一个数组，但不能使用类型参数T创建数组对象。
    3. 不能在静态环境中使用泛型类的类型参数T。
    4. 异常类不能是泛型的，即泛型类不能继承java.lang.Throwable类。
18. 什么是容器、什么是集合p232
    1. collection
    2. set
19. 容器框架中的接口和实现接口的类的继承关系(图)p233
20. 选用LinkedList、还是ArrayList的原则？*LinkedList、ArrayList的**区别**！*p235
    1. 若要通过下标随机访问元素，但除了在末尾处之外，不在其他位置插入或删除元素，应该选择ArrayList类
    2. 若要在线性表的任意位置上进行插入或删除元素，则应选择LinkedList类
21. 什么叫做遍历？p237
    1. **对容器中元素进行访问，经常需要按照某种次序对容器中的每个元素访问且仅访问一次，这就是遍历，也称为迭代。**
    2. **遍历是指从容器中获得当前元素的后续元素。**
22. 遍历的方式？p237
    1. `foreach`循环语句
    2. 使用`Collection`接口中定义的`toArray()`方法将容器对象转换为数组，然后再利用循环语句对数组中的每个元素进行访问。
    3. 利用`size()`和`get()`方法进行遍历，先获取容器内的总个数，然后依次取出每个位置上的元素并访问，如下面的代码段。
    4. 使用java提供的迭代功能。
23. **ListIterator支持对List对象的双向遍历p238**
24. 集合接口Set p239
25. 如何比较两个加入哈希集合HashSet中的元素是否相同p239
26. 构造方法上座率p240
27. **LinkedHashSet让元素有序输出p241**
28. **TreeSet让元素有序p241**
29. p245
30. 什么是泛型实例化？
31. 泛型实例化中的实际类型是什么类型？
32. *泛型方法与泛型类的**区别**？*
33. 并不能使用泛型的类型参数创建对象
34. 三种泛型类通配符
35. 迭代
36. List\Map\Set的对象的**区别**
37. List
38. LinkedList
39. ArrayList
40. Set
41. HashSet
42. TreeSet
43. Map
44. HashMap
45. TreeMap
46. *通配符与类型参数的**区别**：*
    1. 泛型方法中**类型参数**的优势：可以表达多个参数之间或参数与返回值之间的类型依赖关系。
    2. 如果方法中并不存在类型之间的依赖关系，则可以不使用泛型方法，而选用**通配符**。
    3. **通配符**更清晰、简明，在程序开发过程中建议尽量采用通配符。
47. **区别*****Vector<E>与ArrayList<E>的**区别**与联系*
    1. Vector与ArrayList一样，都是通过数组实现的，都有一个初始的容量大小，并可以设置初始的空间大小，当存储的空间不够时，需要增加存储空间，Vector默认增长原来的一倍，而ArrayList是原来的的0.5倍。
    2. **Vector支持线程的同步**，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性
    3. **ArrayList是异步的**，不是线程安全的，但是因为同步影响执行效率，所以ArrayList比Vector性能好。
48. *区别*****HashSet与TreeSet的抉择*
    1. 如果排序很重要，就选择TreeSet，否则应该选用HashSet。
    2. HashSet与LinkedHashSet的抉择：如果一定要让元素有序输出，就要使用LinkedHashSet！
49. **区别**哈希表存储对象的方式与前面所讲的数组与Vector及ArrayList不同：
    1. 数组、Vector及ArrayList中对象的存储位置是随机的，即对象本身与其存储位置之间没有必然的联系。因此查找一个对象时，只能以某种顺序（如顺序查找，二分查找）与各个元素进行比较，如果数组或向量中的元素数量很庞大时，查找的效率必然降低；
    2. 哈希表中，对象的存储位置和对象的关键属性k之间有一个特定的对应关系f，我们称之为哈希(Hash)函数。它使每个对象与一个唯一的存储位置相对应。因而在查找时，只要根据待查对象的关键属性k，计算f(k)的值即可知其存储位置。
---
## 13
1. 基本注解p249
2. 元注解(元数据注解)p250
3. 自定义注解p251
4. 反射机制、定义p252
5. 在Java程序中获得Class类的3种方式p253
6. 内部类定义p258
7. 内部类作用p258
8. 内部类与普通类的**区别**p258
9. 外部类与内部类的访问原则p259
10. 内部类特性p260
11. 匿名内部类定义p260
12. 函数式接口p263
13. lambda表达式p263
---
1. 选择、填空
   1. 抽象方法在“抽象”类，
      1. 包含抽象方法的类一定是抽象类
      2. 抽象类中不一定有抽象方法
      3. 子类必须实现父类的所有抽象方法，才能产生对象
   2. OOP特点，
      1. **封装**、**继承**、**多态**
   3. 在堆栈哪里、
      1. 栈内存：**定义的基本类型的变量**和**对象的引用变量**，超出作用域将自动释放。
      2. 堆内存：存放由new运算符创建的**对象**和**数组**。由Java虚拟机的自动垃圾回收器来管理。
2. 简答
   1. *容器几个的**区别***
      1. Collection
         1. List:可重复，通过索引取出加入数据，顺序与插入顺序一致，可含null
            1. ArrayList:底层array,查询速度快，增删改慢,随机访问速度极快
            2. Vector:底层array,查询速度快，增删改慢
            3. LinkedList:底层链表，增删速度快，查询稍慢
            4. *ArrayList与Vector的**区别**：*
               1.如果集合中的元素数量大于当前集合数组的长度时，Vector的增长率是目前数组长度的100%，而ArryaList增长率为目前数组长度的50%。所以，如果集合中使用数据量比较大的数据，用Vector有一定优势
               2.线程同步ArrayList是线程不同步，所以Vector线程安全，但是因为每个方法都加上了synchronized，所以在效率上小于ArrayList
         2. Set:数据无序且唯一,实现类都不是线程安全的类
            1. HashSet:查询速度，插入的速度也是比较快，但是适用于少量数据的插入操作
            2. LinkedHashSet:保持数据的先后添加顺序、元素不重复、
            3. TreeSet:排序
         3. Map:Map中的键是唯一的，但值可以不唯一
            1. HashMap
               1. **HashMap类允许有空的关键字**，
               2. **而HashTable类不允许空关键字，且线程安全**。
            2. TreeMap
               1. 实现了SortedMap接口；
               2. TreeMap类中**关键字不允许为空**且**升序排列**。
   2. *多线程函数的**区别***
      1. 将一个程序任务分成几个可以同时并发执行的子任务
   3. 内部类、匿名内部类、lambda表达式
   4. 如果处理继承的父类和实现的父接口有同样的方法名？
      1. 提供同名方法的一个新实现
      2. 委托一个父接口的默认方法
   5. *（重载和重写的**区别**）*
      1. 重载：同一类内定义多个名称相同的方法，然后根据其参数的不同（参数个数、参数类型）来设计不同的功能
      2. 覆盖：在子类中定义名称、参数个数、类型均和父类中完全相同的方法，用来重写父类中同名方法。
   6. （构造方法）
   7. （类的声明里面调用该类，this，调用父类super）
   8.  （static和default、final）（访问权限控制符）
   9.  （abstract、static、）（修饰成员变量的关键词）（实例变量与局部变量的**区别**）
   10. *（生命周期和作用域的**区别**）*
       1.  对象
       2.  变量
   11. （object类的**区别**、超类、父类，都会继承**Object类**）
   12. *（thread类和runnable接口，实现多线程的两个方法的**区别**）*
       1.  直接继承Thread类的特点是：
           1.  编写简单，可以直接操纵线程；
           2.  但缺点是若继承Thread类，就不能再继承其他类。
       2.  使用Runnable接口的特点是：
           1.  可以将Thread类与所要处理的任务的类**分开**，形成清晰的模型；
           2.  还可以从其他类继承，从而实现**多重继承**的功能
           3.  相比于Thread类，Runnable**更适合于多个线程**处理同一资源。
           4.  **几乎所有多线程应用**都可以用实现Runnable接口的方式来实现
           5.  主要**区别**就在于对**数据的共享**上。使用Runnable接口可以轻松实现**多个线程共享相同数据**，只要用同一个实现了Runnable接口的类的对象作为参数创建多个线程就可以了
   13. *（自动装箱和拆箱）*
       1. 当编译器发现程序在应该使用`包装类对象`的地方却使用`基本数据类型的数据`时，编译器将自动把`该数据`包装为`该基本类型对应的包装类的对象`，这个过程称为自动包装。
       2. 当编译器发现在应该使用`基本类型数据`的地方却使用了`包装类的对象`，则会把`该包装类对象`解包，从中取出`所包含的基本类型数据`，这个过程称为自动解包。
   14. （基本数据类型有什么）
       1. 数值、字符、布尔
   15. （容器几个的**区别**、多线程函数的**区别**、内部类、匿名内部类、lambda表达式）、
3. 阅读补充程序（判断1~n有几个素数）、
   ```java
   package test;

   public class test10 {
      public static int SingleTest(int n, int amount) {
         int j = 2;
         //3-->n-1
         for (; j < n; j++) {
               //只要有一个余数是0，他就不是素数
               if (n % j == 0) {
                  break;
               }
         }
         //如果刚才循环没有break，j一直增长到了n，那么n就是素数
         if (n == j) {
               amount++;
         }
         return amount;
      }

      public static void main(String[] args) {

         int n = 100;
         int amount = 0;
         for (int i = 1; i < n; i++) {
               amount = SingleTest(i, amount);
         }
         System.out.println(n + "'s prime number amount is " + amount);

      }
   }


   ```
4. 应用编程题(多线程互斥锁、三层循环—深度优先搜索（算法）)
5. Java怎么运行？**先编译后解释**


选择、填空
实现什么作用的关键字是什么？
以下哪一个命名方法不对
子类、父类  Father A = new Son(); 用父类引用子类对象
Package包命名和project命名都纯小写、类命名大驼峰、变量和方法命名小驼峰
位运算不会考；
标准输入输出有哪三个。
Java是行主序
匿名内部类会考
静态代码块的关键字
字节流和字符流的**区别**，节点流和处理流
异常处理一定会考（异常处理的三种方法、try catch final、throw、throws）
自定义的exception
输入输出，文件
通配符
