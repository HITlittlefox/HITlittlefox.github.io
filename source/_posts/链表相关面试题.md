---
title: 链表相关面试题
category: 我要就业
date: 2022-07-07 08:27:54
tags:
---
## 链表问题
### 面试时链表解题的方法论
1. 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度
2. 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法
3. 链表面试常用数据结构和技巧
    1. 使用容器（哈希表，数组等）
    2. 快慢指针
###　快慢指针问题
    1. 输入链表头结点，奇数长度返回**中点**，偶数长度返回**上中点** 
        `1 3 5 2 7 返回 5；1 3 2 7 返回 3`
    2. 输入链表头结点，奇数长度返回**中点**，偶数长度返回**下中点**  
        `1 3 5 2 7 返回 5；1 3 2 7 返回 2`
    3. 输入链表头结点，奇数长度返回**中点前一个**，偶数长度返回**上中点前一个**  
        `1 3 5 2 7 返回 3；1 3 2 7 返回 1`
    4. 输入链表头结点，奇数长度返回**中点前一个**，偶数长度返回**下中点前一个**  
        `1 3 5 2 7 返回 3；1 3 2 7 返回 3`

### 面试题一：判断回文结构
1. 给定一个单链表的头结点head，请判断该链表是否为回文结构。回文就是正着输出和反着输出结果一样
2. 栈的方法特别简单（笔试）
    1. 笔试思路，以此把该链表放入栈中。
    2. 再遍历该链表和栈中弹出的数比对，只要有不一样，就不是回文
3. 改原链表的方法需要注意边界问题（面试用）
    1. 快慢指针解法：
        1. 用快慢指针定位到中点的位置，奇数就是定位到唯一的中点，偶数定位到上中点。
        2. 然后把中点右半部分加入栈中去，那么栈中存的是右半部分的逆序。
        3. 接着从头遍历链表，栈中有多少个元素，我们就比较多少步，如果有对不上就不是回文
    2. 快慢指针最优解，不使用容器结构(stack)，O(1)：
        1. 同样的找到中点位置，中点指向空,把右半部分指针回指到中点。
        2. 接着指针1从L位置，指针2从R位置，往中间遍历。
        3. 每步比对，如果有不一样，则不是回文。返回答案之前，把中点右边的指针调整回来.

![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-11-19.png)
### 面试题二：按值划分单链表
1. 将单链表按某值划分成左边小，中间相等，右边大的形式
2. 把链表放入数组里，在数组上做partion(笔试用)
    1. [3, 2, 4, 7, 0, 2, 1]选择2划分，基于2对数组作partion
3. 分成小、中、大三部分。再把各个部分之间串起来（面试用）
    1. 借助6个引用变量，不需要容器O(N)，且能保证稳定性。
    2. 小于区域的头引用，小于区域的尾引用，
    3. 等于区域的头引用，等于区域的尾引用，
    4. 大于区域的头引用，大于区域的尾引用。
    5. 依次对比给定的值加入到这三个区域，之后串联起来

![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-11-42.png)

### 面试题三 深度克隆带rand的Node
    一种特殊的单链表结构如下：
    ```java
    public static class Node {
            public int value;
            public Node next;
            public Node rand;

            public Node(int data) {
                this.value = data;
            }
        }
    ```
    rand指针式单链表节点结构中新增加的指针，
    rand可能指向链表中的任意一个节点，也可能为null。
    给定一个由Node节点类型组成的无环单链表节点head。
    请实现一个函数完成这个链表的复制，并返回复制的新链表的头结点。

    要求:时间复杂度为O(N)，额外空间复杂度为O(1)

1. 哈希表方法(笔试推荐)
    1. 第一步遍历，把所有节点加入到Map<Node, Node>表示老节点到克隆出来的节点映射
    2. 第二步遍历，查map找到克隆节点，最后返回头结点
![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-12-52.png)
2. 不用哈希表的方法，人为构造对应关系(面试推荐)
    1. 第一步：每个节点遍历的时候克隆出来一个新的节点加入到当前节点和其next节点的中间
    2. 第二步：此时经过第一步所有节点和其克隆节点都是串在一起的，依次拿出当前节点和其克隆节点，当前节点的rand指针指向的节点的克隆节点给当前节点克隆的节点的rand节点指向的节点。
    3. 第三步：此时老节点的rand指针没变化，克隆节点的rand指针也都指向了对应的克隆节点。此时在大的链表上分离出来原链表和克隆链表
![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-13-22.png)
### 面试题四:相交链表节点/约瑟夫环
0. 三个面试题的合集
    1. 返回的单链表的入环节点
    2. 两个无环链表相交,返回第一个入环节点
    3. 两个有环链表相交,返回第一个入环节点
1. 该问题和约舍夫环问题是链表问题的比较难的问题
    1. 题目描述：给定两个可能有环也可能无环的单链表，头结点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
    2. 要求：如果两个链表长度之和为N，时间复杂度请达到O(N)，额为空间复杂度请达到O(1)
    3. (解释:这道题,与链表上的值是什么,一点关系也没有,只和内存地址有关,相交就是共不共用公共部分)
2. 思路：由于是单链表，则一旦成环就结束，出不来，因为每个节点只有一个Next指针
3. **核心问题:单个链表是否成环**
    1. 输入:头节点
    2. 输出:如果成环输出第一个成环节点,否则输出null
    3. 方法一:
        1. 用set把每个节点的内存地址放到set里面，
        2. 如果存在相同的内存在set中存在，则就是第一个成环的节点
        3. 如果不存在,就会走到null![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-14-05.png)
    4. 方法二:
        1. 用快慢指针对链表遍历，那么快慢指针一定会相遇，能相遇就说明存在环。
            1. 快指针F:1次走**2**步,第三个节点出发
            2. 慢指针S:1次走**1**步,第二个节点出发
        2. 然后让慢指针S停在相遇的位置，快指针F回到头结点。
        3. 快慢指针再出发:
            1. 快指针F:1次走**1**步,从头节点出发
            2. 慢指针S:1次走**1**步,从相遇位置出发
            3. 再次相遇的节点就是成环节点![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-22-30.png)
4. 可能性:
    1. loop1 和 loop2 都为null:可能不相交,可能相交
    2. 一个为空,另一个不为空:一定不相交
    3. 两个都不为空:
        1. 独立有环
        2. 都有公共环,入环节点相同:loop1内存地址==loop2内存地址
        3. 都有公共环,入环节点不相同:
        4. 关于1和3:让loop1往下走,如果能遇到loop2,那就是3的情况;如果遇不到loop2,那就是1的情况![](https://raw.githubusercontent.com/HITlittlefox/HITlittlefox.github.io/main/source/_posts/image/2022-07-07-16-22-49.png)
5. loop1 和 loop2 都为null:如果两个链表都无环，返回第一个相交节点，如果不相交，返回null
    1. 方法一:hashSet(先检查后放入):把第一个链表的全部节点放入,再放第二个链表的全部节点,如果重复,则代表相交,返回该节点
    2. 方法二:
        1. length1:head1走到end1
        2. length2:head2走到end2
        3. 先判断内存地址end1=?=end2
            1. 如果不相等,则不会相交
            2. 如果相等,就相交:假设l1=100,l2=80,则head1先走20步,来到某个位置,然后两个链表一起走,一定会得到相遇位置

### 题目描述：能不能不给单链表的头结点，只给想要删除的节点，就能做到在链表上把这个点删掉？
1. 抖机灵的做法，1->2->3->4->5->null，给定3。
    1. 那么根据内存地址找到3这个节点，把3下个节点赋值给自身变成4，
    2. 再把自身的下一个指针指向下下个值5即可。1->2->4->5->null。
    3. 缺点:
        1. 没把原始节点删除，
        2. 只是改变了值，内存地址没被删掉而是删掉了需要删除节点的下一个内存地址。
        3. 该方法无法删除链表的最后一个节点
2. 实质上不给头结点，无法删除给定的节点。
    1. 没有头结点，没法准确的连指针