---
title: Java-promote-MOOC  
date: 2021-08-10 00:00:00  
tags:  
category: Java
---

### 学习地点：中国大学MOOC 翁恺老师 《面向对象程序设计——Java语言》

1. 类与对象

    1. 用类制造对象
        1. 类是规范，根据类的定义来创建对象。
        2. 对象是实体，需要被创建，可以为我们做事情；
        3. 对象=属性+服务，数据表示属性或形态，例如画圆时的圆心和半径，
        4. 把数据和对数据的操作放在一起，称为封装。
    2. 定义类
        1. 类由两种东西构成：
        2. 表示对象有什么成员变量；
        3. 表示对象能做什么成员函数；
    3. 成员变量和成员函数
        1. 成员
            1. 类才具有成员，包括”成员变量“和“成员函数”；
            2. 类中的成员变量是一个声明；变量不在类里，
            3. 变量在每一个对象里；
        2. 本地变量：
            1. 定义在类的函数（方法）内部的变量；
            2. 本地变量的作用域和生存期在函数的内部。
        3. 成员变量：
            1. 类定义了对象中所具有的变量，这些变量称作成员变量；
            2. 写在类里的变量，生存期是对象的生存期，作用域是类内部的成员函数。
            3. 每个对象都有自己的变量，和同一个类的其他对象是分开的。
            4. （本地变量和成员变量的区别？）
        4. 函数与成员变量
            1. 在函数中，可以直接写成员变量的名字来访问成员变量；
            2. this是成员函数特殊的（固有的）本地变量，它表达了调用这个函数时的那个对象；
    4. 对象初始化
        1. Java可以给每个成员变量默认的“0”值、定义初始化和构造函数
        2. 成员变量定义和初始化
        3. 成员变量在定义的地方就可以给出初始值；
        4. 未给出初始值的成员变量会自动获得0值；
        5. 构造函数
        6. 在构造（对象）的时候会自动调用的函数叫作构造函数；构造函数不能有返回类型。
        7. 函数重载（方法重载）
        8. 一个类里的同名但参数表不同的函数构成了重载关系（overload）
        9. 创建对象的时候给出不同的参数值，就会自动调用不同的构造函数；
        10. (?)通过this()还可以调用其它构造函数；
2. 对象交互
    1. 对象交互
        1. 对象的识别
        2. 对象的交互  
           Display有两个对象hour、minute在Clock类中，使用clock中的一个start方法使得“minute的增加可以导致hour的增加”
        1. 高内聚低耦合:  
           低耦合:是对象和对象之间的耦合尽可能的松，平行的对象要尽量减少直接联系，让更高层次的对象来提供通信服务。
    2. 访问属性
        1. private
        2. 只有这个类内部可以访问
        3. 类内部指类的成员函数和定义初始化
        4. 这个限制是对类的而不是对对象的
        5. 同一个类的不同的对象之间可以互相访问别人的私有的成员
        6. 私有是针对类而不是针对对象
        7. public
        8. 任何类的函数或定义初始化种都可以调用、访问或定义变量。
        9. 类的前面通常也会加public，表明任何人都可以用类的定义来定义变量； 但是加了public的类必须保存在同名的.java文件里，否则会报错；
    3. 包package 点 com.fox.www
    4. 类变量
        1. static变量是类的变量。
        2. 类函数：static函数是类的函数。可以在类函数中调用其他类函数
        3. static的成员变量只会在类进入程序里面的时候（类的装载）被初始化，在后面不会初始化
3. 对象容器
    1. ArrayList 类 表示用来存放string的arraylist
        ```
        private ArrayList<String> notes = new ArrayList<String>();
        ```
       ArrayList是容器的类型、尖括号里面的是元素的类型
    2. 对象数组中的每个元素都是对象的管理者而非对象本身
4. 继承与多态
    1. 父类的东西都继承给了子类，子类都得到了，但是如果父类的东西是private的，子类自己不能碰，可是可以通过父类的函数去碰，在谁的函数里面指的成员变量就是谁的；
    2. 如果父类与子类出现同名的成员变量，子类函数里面所指的成员变量就是子类自己的；父类函数里面所指的就是父类自己的，他们之间无联系。
    3. 多态： Java的对象变量是多态的，它们能保存不止一种类型的对象  
       它们可以保存的是声明类型的对象，或声明类型的子类的对象  
       当把子类的对象赋给父类的变量的时候，就发生了向上造型
    4. 造型cast：
        1. 子类的对象可以赋值给父类的变量；父类的对象不能赋值给子类的变量!
        2. 注意! Java中不存在对象对对象的赋值!
        3. 把子类的对象赋给父类的变量是安全的
        4. 把父类的对象赋给子类的变量是不行的。
        5. 用括号围起类型放在值的前面
        6. 对象本身并没有发生任何变化，所以不是“类型转换”
        7. 运行时有机制来检查这样的转化是否合理  
           classCastException
    5. 类型转换与造型的区别？  
       类型转换是改变了原值
       ```
       int i = (int)10.2;
       ```
       造型只是把这个对象当作造型后的来看待，没有改变对象的值。
       ```
       CD cc = (CD)item;
       ```
    6. 向上造型
        1. 拿一个子类的对象，
        2. 当作父类的对象来用向上造型是默认的，
        3. 不需要运算符
        4. 向上造型总是安全的
    7. 函数调用的绑定
        1. 当通过对象变量调用函数的时候，调用哪个函数这件事情叫做绑定
        2. 静态绑定:根据变量的声明类型来决定
        3. 动态绑定:根据变量的动态类型来决定
        4. 在成员函数中调用其他成员函数也是通过this这个对象变量来调用的
    8. 覆盖override
        1. 子类和父类中存在名称和参数表完全相同的函数，这一对函数构成覆盖关系
        2. 通过父类的变量调用存在覆盖关系的函数时会调用变量当时所管理的对象所属的类的函数
    9. 类型系统
        1. 单根结构：所有的类都是继承自Object的
        2. object类
        3. toString();
        4. equals();
        5. 增加新的媒体类型
        6. 代码不需要进行修改就可以扩展适应新的数据和内容叫做可扩展性
        7. 代码需要进行修改就可以扩展适应新的数据和内容叫做可维护性
5. 设计原则（城堡游戏）
    1. 增加可扩展性
        1. 可以运行的代码!=良好的代码
        2. 对代码做维护的时候最能看出代码的质量
    2. 用封装来降低耦合
        1. Room类和Game类都有大量的代码和出口相关
        2. 尤其是Game类中大量使用了Room类的成员变量
        3. 类和类之间的关系称作耦合
        4. 耦合越低越好，保持距离是形成良好代码的关键
        5. 用接口来实现聚合
        6. 给Room类实现的新方法，把方向的细节彻底隐藏在Room类内部了
        7. 今后方向如何实现就和外部无关了
        8. 用容器来实现灵活性
        9. Room的方向是用成员变量表示的，增加或减少方向就要改变代码
        10. 如果用Hash表来表示方向，那么方向就不是“硬编码”的了
        11. 以框架+数据来提高可扩展性
        12. 命令的解析是否可以脱离if-else
        13. 定义一个Handler来处理命令
        14. 用Hash表来保存命令和Handler之间的关系
6. 抽象与接口
    1. 抽象函数、抽象类
        1. 抽象函数——表达概念而无法实现具体代码的函数
        2. 抽象类——表达概念而无法构造出实体的类
        3. 带有abstract修饰符的函数
        4. 有抽象函数的类一定是抽象类
        5. 抽象类不能制造对象但是可以定义变量  
           任何继承了抽象类的非抽象类的对象可以付给这个变量
    2. 实现抽象函数  
       继承自抽象类的子类必须覆盖父类中的抽象函数，父类的抽象方法全都要用！如果不用，那就得把该子类变成abstract，但是抽象后就不能制造对象了嗷。
    3. 数据与表现分离
        1. 程序的业务逻辑与表现无关
        2. 表现可以是图形的也可以是文本的
        3. 表现可以是当地的也可以是远程的
    4. 责任驱动的设计  
       将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环
    5. 网格化  
       图形界面本身有更高的解析度  
       但是将画面网格化以后，数据就更容易处理了
    6. 面向接口的编程方式
        1. 设计程序时先定义接口，再实现类
        2. 任何需要在函数间传入传出的一定是接口而不是具体的类
        3. 是Java成功的关键之一，因为极适合多人同时写要给大程序
        4. 也是Java被批评的要点之一，因为代码量膨胀起来很快
    7. 内部类
        1. 定义在别的类内部、函数内部的类
        2. 内部类能直接访问外部的全部资源
        3. 包括任何私有的成员
        4. 外部是函数时，只能访问那个函数里final的变量
    8. 匿名类
    5. 在new对象的时候给出的类的定义形成了匿名
    6. 匿名类可以继承某类，也可以实现某接口
    7. Swing的消息机制广泛使用匿名类
7. 控制反转与MVC模式
    1. 注入反转  
       由按钮公布一个守听者接口和一对注册/注销函数  
       你的代码实现那个接口，将守听者对象注册在按钮上  
       一旦按钮被按下，就会反过来调用你的守听者对象的某个函数
    2. MVC模式
        1. JTable：用JTable类可以以表格的形式显示和编辑数据。JTable类的对象并不存储数据，它只是数据的表现。（数据和表现分开了）
        2. 数据、表现和控制三者分离，各负其责。
        3. M=Model(模型),V=View(表现),C=Control(控制)
        4. 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新。
        5. 表现：从模型获得数据，根据数据画出表现。
        6. 控制：从用户得到输入，根据输入调整数据。
8. 异常处理与输入输出
    1. 异常
    2. 异常机制
    3. 什么可以扔? 任何继承了Throwable类的对象。
    4. 吧啦吧啦吧啦~
9. 流stream
    1. 有时候需要try except
    2. 可以套娃！
