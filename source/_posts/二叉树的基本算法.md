---
title: 二叉树的基本算法
category: 大三下
date: 2022-07-07 16:23:26
tags:
---
## 二叉树基本算法
1. 二叉树的遍历
2. 二叉树节点定义
    ```java
	public static class Node {
		public int value;
		// 二叉树的左孩子指针
		public Node left;
		// 二叉树的右孩子指针
		public Node right;

		public Node(int v) {
			value = v;
		}
	}
    ```
3. 递归实现先序中序后序遍历
    1. 先序：头 左 右
    2. 中序：左 头 右
    3. 后序：左 右 头
### 递归序:
1. 结论：对于树的递归，每个节点实质上会到达三次，
2. 例如上文的树结构，对于f函数，我们传入头结点，再调用左树再调用右树。
3. 实质上经过的路径为1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1。
4. 我们在每个节点三次返回的基础上，
    1. 第一次到达该节点就打印，就是先序，
    2. 第二次到达该节点打印就是中序，
    3. 第三次到达该节点才打印,就是后序。
5. 所以先序中序后序，只是我们的递归顺序加工出来的结果！
6. 任何一个节点,
    1. 都有机会去左树转一圈回到他,收集一些信息
    2. 都有机会去右树转一圈回到他,收集一些信息
    3. 还能第三次回到他,把信息做整合,这是在树上做动态规划的基础
### 非递归实现**先序**遍历(DFS)
1. 思路：由于任何递归可以改为非递归,我们可以使用压栈来实现,实质就是深度优先遍历（DFS）。用先序实现的步骤，其他类似：
2. 步骤一，把节点压入栈中，弹出就打印
3. 步骤二，如果有右孩子先压入右孩子
4. 步骤三，如果有左孩子压入左孩子
5. 得到头,左,右
### 非递归实现**后序**遍历
1. 步骤一，把节点压入栈中，弹出就打印
2. 步骤二，如果有左孩子压入左孩子
3. 步骤三，如果有右孩子先压入右孩子
4. 得到的是头,右,左;逆序,得到,左,右,头.
### 非递归实现**中序**遍历
1. 步骤一，整条左边界依次入栈
2. 步骤二，无法继续(1),弹出并打印,来到右子树,继续执行(1)

### 单个栈完成后序遍历(图一乐)


### 二叉树按层遍历(BFS)(按层打印输出二叉树)
1. 其实就是宽度优先遍历(BFS)，用队列(左进右出)
    1. `Code01_LevelTraversalBT`    
    2. 先把root放入队列,
    3. 从队列中拿出一个,打印,先加左再加右,
    4. 重复
2. 可以通过设置flag变量的方式，来发现某一层的结束


### 统计二叉树的最大宽度(哪一层的节点数量最多,有多少)
1. `Code05_TreeMaxWidth`
2. 要求不仅能打印
3. 还要能知道开始和结束
4. 核心:发现层结束的机制(**经常考**)
5. 两种方式:
    1. 使用Map
    2. 使用Queue
### 二叉树的序列化和反序列化
1. 先序或者中序或者后序遍历,序列化
    1. 每个叶节点都补齐null
2. 按层遍历，序列化
    1. 每个叶节点都补齐null
    2. 弹出时,左孩子!=空:序列化,也加队列
    3. 弹出时,左孩子==空:只序列化,不加队列
3. 用了什么方式的序列化，就用什么方式的反序列化
4. 由于如果树上的节点值相同，那么序列化看不出来该树的结构，所以我们的序列化要加上空间结构的标识，空节点补全的方式。

### 直观打印一颗二叉树
如何设计一个打印整颗数的打印函数,简单起见，我们躺着打印，正常的树我们顺时针旋转90°即可

### 题目一：返回二叉树的后继节点
二叉树的结构定义如下：
```java
Class Node {
    V value;
    Node left;
    Node right;
    // 指向父亲节点
    Node parent;
}
```
1. `Code07_PaperFolding`
2. 给你二叉树中的某个节点，返回该节点的后继节点。
    1. 后继节点表示一颗二叉树中，在中序遍历的序列中，一个个节点的下一个节点是谁。
3. 方法一，通常解法思路：
    1. 由于我们的节点有指向父节点的指针，而整颗二叉树的头结点的父节点为null。
    2. 那么我们可以找到整棵树的头结点，然后中序遍历，再找到给定节点的下一个节点，就是该节点的后续节点。
4. 方法二，考虑一个节点和其后继节点的结构之间的关系：
    1. 如果一个节点x有右树，那么其后继节点就是**右树最左的节点**。
    2. 如果x没有右树，往上找父亲节点。
        1. 如果x是其父亲的右孩子继续往上找，
        2. 如果某节点是其父亲节点的左孩子，那么该节点的父亲就是x的后继节点
    3. 即如果某节点左树的最右节点是x，那么该节点是x的后继
    4. 如果找父节点，一直找到null都不满足，那么该节点是整棵树的最右节点，没有后继

### 折纸问题请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。
1. 问题:
    1. 此时折痕是凹下去的，即折痕凸起的方向指向纸条的背面。
    2. 如果从纸条的下边向上方对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕，下折痕和上折痕。
    3. 给定一个输入参数N,代表纸条都从下边向上方连续对折N次。请从上到下打印所有的折痕的方向。
2. 例如：N=1时，打印: down 。N=2时，打印：down down up
3. 规律:
    1. 大于一次后，每次折痕出现的位置都是在上次折痕的上方出现凹折痕，下方出现凸折痕。
    2. 所以我们没必要构建这颗树，就可以用递归思维解决
    3. 从上到下打印整张纸的凹凸情况就是整棵树的中序遍历。